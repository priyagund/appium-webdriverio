"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Usbmux = void 0;
exports.getDefaultSocket = getDefaultSocket;

require("source-map-support/register");

var _net = _interopRequireDefault(require("net"));

var _os = _interopRequireDefault(require("os"));

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _support = require("@appium/support");

var _lengthBasedSplitter = _interopRequireDefault(require("../util/transformer/length-based-splitter"));

var _usbmuxDecoder = _interopRequireDefault(require("./transformer/usbmux-decoder.js"));

var _usbmuxEncoder = _interopRequireDefault(require("./transformer/usbmux-encoder.js"));

var _path = _interopRequireDefault(require("path"));

var _plistService = _interopRequireDefault(require("../plist-service"));

var _lockdown = require("../lockdown");

var _baseService = require("../base-service");

var _constants = require("../constants");

const MAX_FRAME_SIZE = 1 * _constants.MB;
const USBMUX_RESULT = {
  OK: 0,
  BADCOMMAND: 1,
  BADDEV: 2,
  CONNREFUSED: 3
};
let name, version;

try {
  ({
    name,
    version
  } = require(_path.default.resolve(__dirname, '..', '..', '..', 'package.json')));
} catch (err) {
  ({
    name,
    version
  } = require(_path.default.resolve(__dirname, '..', '..', 'package.json')));
}

const DEFAULT_USBMUXD_SOCKET = '/var/run/usbmuxd';
const DEFAULT_USBMUXD_PORT = 27015;
const DEFAULT_USBMUXD_HOST = '127.0.0.1';
const PROG_NAME = name;
const CLIENT_VERSION_STRING = `${name}-${version}`;

function swap16(val) {
  return (val & 0xFF) << 8 | val >> 8 & 0xFF;
}

async function getDefaultSocket(opts = {}) {
  const {
    socketPath = DEFAULT_USBMUXD_SOCKET,
    socketPort = DEFAULT_USBMUXD_PORT,
    socketHost = DEFAULT_USBMUXD_HOST,
    timeout = 5000
  } = opts;
  let socket;

  if (await _support.fs.exists(socketPath)) {
    socket = _net.default.createConnection(socketPath);
  } else if (process.platform === 'win32' || process.platform === 'linux' && /microsoft/i.test(_os.default.release())) {
    socket = _net.default.createConnection(socketPort, socketHost);
  } else {
    throw new Error(`The usbmuxd socket at '${socketPath}' does not exist or is not accessible`);
  }

  return await new _bluebird.default((resolve, reject) => {
    socket.once('error', reject);
    socket.once('connect', () => resolve(socket));
  }).timeout(timeout);
}

class Usbmux extends _baseService.BaseServiceSocket {
  constructor(socketClient) {
    super(socketClient);
    this._decoder = new _usbmuxDecoder.default();
    this._splitter = new _lengthBasedSplitter.default({
      readableStream: socketClient,
      littleEndian: true,
      maxFrameLength: MAX_FRAME_SIZE,
      lengthFieldOffset: 0,
      lengthFieldLength: 4,
      lengthAdjustment: 0
    });

    this._socketClient.pipe(this._splitter).pipe(this._decoder);

    this._encoder = new _usbmuxEncoder.default();

    this._encoder.pipe(this._socketClient);

    this._assignClientFailureHandlers(this._encoder);

    this._tag = 0;
    this._responseCallbacks = {};

    this._decoder.on('data', this._handleData.bind(this));
  }

  _handleData(data) {
    const cb = this._responseCallbacks[data.header.tag] || _lodash.default.noop;
    cb(data);
  }

  async readBUID(timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.BUID) {
        return data.payload.BUID;
      }

      throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ReadBUID',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  async readPairRecord(udid, timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (!data.payload.PairRecordData) {
        return null;
      }

      try {
        return _support.plist.parsePlist(data.payload.PairRecordData);
      } catch (err) {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ReadPairRecord',
        PairRecordID: udid,
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  _sendPlist(json) {
    this._encoder.write(json);
  }

  _receivePlistPromise(timeout = 5000, responseCallback) {
    const tag = this._tag++;
    const receivePromise = new _bluebird.default((resolve, reject) => {
      this._responseCallbacks[tag] = data => {
        try {
          resolve(responseCallback(data));
        } catch (e) {
          reject(e);
        }
      };

      setTimeout(() => reject(new Error(`Failed to receive any data within the timeout: ${timeout}`)), timeout);
    });
    return {
      tag,
      receivePromise
    };
  }

  async listDevices(timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.DeviceList) {
        return data.payload.DeviceList;
      }

      throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ListDevices',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  async findDevice(udid, timeout = 5000) {
    const devices = await this.listDevices(timeout);
    return _lodash.default.find(devices, device => device.Properties.SerialNumber === udid);
  }

  async connectLockdown(udid, timeout = 5000) {
    const device = await this.findDevice(udid, timeout);

    if (!device) {
      throw new Error(`Could not find the expected device '${udid}'`);
    }

    const socket = await this.connect(device.Properties.DeviceID, _lockdown.LOCKDOWN_PORT, timeout);
    return new _lockdown.Lockdown(new _plistService.default(socket));
  }

  async connect(deviceID, port, timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.MessageType !== 'Result') {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }

      if (data.payload.Number === USBMUX_RESULT.OK) {
        this._splitter.shutdown();

        this._socketClient.unpipe(this._splitter);

        this._splitter.unpipe(this._decoder);

        return this._socketClient;
      } else if (data.payload.Number === USBMUX_RESULT.CONNREFUSED) {
        throw new Error(`Connection was refused to port ${port}`);
      } else {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'Connect',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING,
        DeviceID: deviceID,
        PortNumber: swap16(port)
      }
    });

    return await receivePromise;
  }

}

exports.Usbmux = Usbmux;
var _default = Usbmux;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNQVhfRlJBTUVfU0laRSIsIk1CIiwiVVNCTVVYX1JFU1VMVCIsIk9LIiwiQkFEQ09NTUFORCIsIkJBRERFViIsIkNPTk5SRUZVU0VEIiwibmFtZSIsInZlcnNpb24iLCJyZXF1aXJlIiwicGF0aCIsInJlc29sdmUiLCJfX2Rpcm5hbWUiLCJlcnIiLCJERUZBVUxUX1VTQk1VWERfU09DS0VUIiwiREVGQVVMVF9VU0JNVVhEX1BPUlQiLCJERUZBVUxUX1VTQk1VWERfSE9TVCIsIlBST0dfTkFNRSIsIkNMSUVOVF9WRVJTSU9OX1NUUklORyIsInN3YXAxNiIsInZhbCIsImdldERlZmF1bHRTb2NrZXQiLCJvcHRzIiwic29ja2V0UGF0aCIsInNvY2tldFBvcnQiLCJzb2NrZXRIb3N0IiwidGltZW91dCIsInNvY2tldCIsImZzIiwiZXhpc3RzIiwibmV0IiwiY3JlYXRlQ29ubmVjdGlvbiIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInRlc3QiLCJvcyIsInJlbGVhc2UiLCJFcnJvciIsIkIiLCJyZWplY3QiLCJvbmNlIiwiVXNibXV4IiwiQmFzZVNlcnZpY2VTb2NrZXQiLCJjb25zdHJ1Y3RvciIsInNvY2tldENsaWVudCIsIl9kZWNvZGVyIiwiVXNibXV4RGVjb2RlciIsIl9zcGxpdHRlciIsIkxlbmd0aEJhc2VkU3BsaXR0ZXIiLCJyZWFkYWJsZVN0cmVhbSIsImxpdHRsZUVuZGlhbiIsIm1heEZyYW1lTGVuZ3RoIiwibGVuZ3RoRmllbGRPZmZzZXQiLCJsZW5ndGhGaWVsZExlbmd0aCIsImxlbmd0aEFkanVzdG1lbnQiLCJfc29ja2V0Q2xpZW50IiwicGlwZSIsIl9lbmNvZGVyIiwiVXNibXV4RW5jb2RlciIsIl9hc3NpZ25DbGllbnRGYWlsdXJlSGFuZGxlcnMiLCJfdGFnIiwiX3Jlc3BvbnNlQ2FsbGJhY2tzIiwib24iLCJfaGFuZGxlRGF0YSIsImJpbmQiLCJkYXRhIiwiY2IiLCJoZWFkZXIiLCJ0YWciLCJfIiwibm9vcCIsInJlYWRCVUlEIiwicmVjZWl2ZVByb21pc2UiLCJfcmVjZWl2ZVBsaXN0UHJvbWlzZSIsInBheWxvYWQiLCJCVUlEIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9zZW5kUGxpc3QiLCJNZXNzYWdlVHlwZSIsIlByb2dOYW1lIiwiQ2xpZW50VmVyc2lvblN0cmluZyIsInJlYWRQYWlyUmVjb3JkIiwidWRpZCIsIlBhaXJSZWNvcmREYXRhIiwicGxpc3QiLCJwYXJzZVBsaXN0IiwiUGFpclJlY29yZElEIiwianNvbiIsIndyaXRlIiwicmVzcG9uc2VDYWxsYmFjayIsImUiLCJzZXRUaW1lb3V0IiwibGlzdERldmljZXMiLCJEZXZpY2VMaXN0IiwiZmluZERldmljZSIsImRldmljZXMiLCJmaW5kIiwiZGV2aWNlIiwiUHJvcGVydGllcyIsIlNlcmlhbE51bWJlciIsImNvbm5lY3RMb2NrZG93biIsImNvbm5lY3QiLCJEZXZpY2VJRCIsIkxPQ0tET1dOX1BPUlQiLCJMb2NrZG93biIsIlBsaXN0U2VydmljZSIsImRldmljZUlEIiwicG9ydCIsIk51bWJlciIsInNodXRkb3duIiwidW5waXBlIiwiUG9ydE51bWJlciJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi91c2JtdXgvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5ldCBmcm9tICduZXQnO1xuaW1wb3J0IG9zIGZyb20gJ29zJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBwbGlzdCwgZnMgfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IExlbmd0aEJhc2VkU3BsaXR0ZXIgZnJvbSAnLi4vdXRpbC90cmFuc2Zvcm1lci9sZW5ndGgtYmFzZWQtc3BsaXR0ZXInO1xuaW1wb3J0IFVzYm11eERlY29kZXIgZnJvbSAnLi90cmFuc2Zvcm1lci91c2JtdXgtZGVjb2Rlci5qcyc7XG5pbXBvcnQgVXNibXV4RW5jb2RlciBmcm9tICcuL3RyYW5zZm9ybWVyL3VzYm11eC1lbmNvZGVyLmpzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IFBsaXN0U2VydmljZSBmcm9tICcuLi9wbGlzdC1zZXJ2aWNlJztcbmltcG9ydCB7IExvY2tkb3duLCBMT0NLRE9XTl9QT1JUIH0gZnJvbSAnLi4vbG9ja2Rvd24nO1xuaW1wb3J0IHsgQmFzZVNlcnZpY2VTb2NrZXQgfSBmcm9tICcuLi9iYXNlLXNlcnZpY2UnO1xuaW1wb3J0IHsgTUIgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5cbmNvbnN0IE1BWF9GUkFNRV9TSVpFID0gMSAqIE1CO1xuXG5jb25zdCBVU0JNVVhfUkVTVUxUID0ge1xuICBPSzogMCxcbiAgQkFEQ09NTUFORDogMSxcbiAgQkFEREVWOiAyLFxuICBDT05OUkVGVVNFRDogMyxcbn07XG5cbmxldCBuYW1lLCB2ZXJzaW9uO1xudHJ5IHtcbiAgLy8gZmlyc3QgdHJ5IGFzc3VtaW5nIHRoaXMgaXMgaW4gdGhlIGBidWlsZGAgZm9sZGVyXG4gICh7IG5hbWUsIHZlcnNpb24gfSA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJywgJ3BhY2thZ2UuanNvbicpKSk7XG59IGNhdGNoIChlcnIpIHtcbiAgLy8gdGhlbiB0cnkgYXNzdW1pbmcgaXQgaXMgbm90XG4gICh7IG5hbWUsIHZlcnNpb24gfSA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJ3BhY2thZ2UuanNvbicpKSk7XG59XG5cbmNvbnN0IERFRkFVTFRfVVNCTVVYRF9TT0NLRVQgPSAnL3Zhci9ydW4vdXNibXV4ZCc7XG5jb25zdCBERUZBVUxUX1VTQk1VWERfUE9SVCA9IDI3MDE1O1xuY29uc3QgREVGQVVMVF9VU0JNVVhEX0hPU1QgPSAnMTI3LjAuMC4xJztcbmNvbnN0IFBST0dfTkFNRSA9IG5hbWU7XG5jb25zdCBDTElFTlRfVkVSU0lPTl9TVFJJTkcgPSBgJHtuYW1lfS0ke3ZlcnNpb259YDtcblxuZnVuY3Rpb24gc3dhcDE2ICh2YWwpIHtcbiAgcmV0dXJuICgodmFsICYgMHhGRikgPDwgOCkgfCAoKHZhbCA+PiA4KSAmIDB4RkYpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNvY2tldE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gc29ja2V0UGF0aCBbL3Zhci9ydW4vdXNibXV4ZF0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgdXNibXV4ZCBVbml4IHNvY2tldFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBzb2NrZXRQb3J0IFsyNzAxNV0gVGhlIHBvcnQgbnVtYmVyIHRvIGNvbm5lY3QgdG8gaWYgcnVubmluZyBvbiBXaW5kb3dzXG4gKiBvciBpbiBXU0wxIG1vZGVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gc29ja2V0SG9zdCBbMTI3LjAuMC4xXSBUaGUgaG9zdCBuYW1lIHRvIGNvbm5lY3QgdG8gaWYgcnVubmluZyBvbiBXaW5kb3dzXG4gKiBvciBpbiBXU0wxIG1vZGVcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gdGltZW91dCBbNTAwMF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB1bnRpbFxuICogdGhlIHNvY2tldCBpcyBjb25uZWN0ZWRcbiAqL1xuXG4vKipcbiAqIENvbm5lY3RzIGEgc29ja2V0IHRvIHVzYm11eGQgc2VydmljZVxuICpcbiAqIEBwYXJhbSB7P1NvY2tldE9wdGlvbnN9IG9wdHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgYWNjZXNzaW5nIHRoZSBzb2NrZXQgb3JcbiAqIGEgY29ubmVjdGlvbiBlcnJvciBoYXBwZW5lZFxuICogQHRocm93cyB7Qi5UaW1lb3V0RXJyb3J9IGlmIGNvbm5lY3Rpb24gdGltZW91dCBoYXBwZW5lZFxuICogQHJldHVybnMge25ldC5Tb2NrZXR9IENvbm5lY3RlZCBzb2NrZXQgaW5zdGFuY2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdFNvY2tldCAob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBzb2NrZXRQYXRoID0gREVGQVVMVF9VU0JNVVhEX1NPQ0tFVCxcbiAgICBzb2NrZXRQb3J0ID0gREVGQVVMVF9VU0JNVVhEX1BPUlQsXG4gICAgc29ja2V0SG9zdCA9IERFRkFVTFRfVVNCTVVYRF9IT1NULFxuICAgIHRpbWVvdXQgPSA1MDAwLFxuICB9ID0gb3B0cztcblxuICBsZXQgc29ja2V0O1xuICBpZiAoYXdhaXQgZnMuZXhpc3RzKHNvY2tldFBhdGgpKSB7XG4gICAgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oc29ja2V0UGF0aCk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICAgICAgfHwgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcgJiYgL21pY3Jvc29mdC9pLnRlc3Qob3MucmVsZWFzZSgpKSkpIHtcbiAgICAvLyBDb25uZWN0IHRvIHVzYm11eGQgd2hlbiBydW5uaW5nIG9uIFdTTDFcbiAgICBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbihzb2NrZXRQb3J0LCBzb2NrZXRIb3N0KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB1c2JtdXhkIHNvY2tldCBhdCAnJHtzb2NrZXRQYXRofScgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGFjY2Vzc2libGVgKTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc29ja2V0Lm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICBzb2NrZXQub25jZSgnY29ubmVjdCcsICgpID0+IHJlc29sdmUoc29ja2V0KSk7XG4gIH0pLnRpbWVvdXQodGltZW91dCk7XG59XG5cblxuY2xhc3MgVXNibXV4IGV4dGVuZHMgQmFzZVNlcnZpY2VTb2NrZXQge1xuICBjb25zdHJ1Y3RvciAoc29ja2V0Q2xpZW50KSB7XG4gICAgc3VwZXIoc29ja2V0Q2xpZW50KTtcblxuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgVXNibXV4RGVjb2RlcigpO1xuICAgIHRoaXMuX3NwbGl0dGVyID0gbmV3IExlbmd0aEJhc2VkU3BsaXR0ZXIoe1xuICAgICAgcmVhZGFibGVTdHJlYW06IHNvY2tldENsaWVudCxcbiAgICAgIGxpdHRsZUVuZGlhbjogdHJ1ZSxcbiAgICAgIG1heEZyYW1lTGVuZ3RoOiBNQVhfRlJBTUVfU0laRSxcbiAgICAgIGxlbmd0aEZpZWxkT2Zmc2V0OiAwLFxuICAgICAgbGVuZ3RoRmllbGRMZW5ndGg6IDQsXG4gICAgICBsZW5ndGhBZGp1c3RtZW50OiAwLFxuICAgIH0pO1xuICAgIHRoaXMuX3NvY2tldENsaWVudC5waXBlKHRoaXMuX3NwbGl0dGVyKS5waXBlKHRoaXMuX2RlY29kZXIpO1xuXG4gICAgdGhpcy5fZW5jb2RlciA9IG5ldyBVc2JtdXhFbmNvZGVyKCk7XG4gICAgdGhpcy5fZW5jb2Rlci5waXBlKHRoaXMuX3NvY2tldENsaWVudCk7XG4gICAgdGhpcy5fYXNzaWduQ2xpZW50RmFpbHVyZUhhbmRsZXJzKHRoaXMuX2VuY29kZXIpO1xuXG4gICAgdGhpcy5fdGFnID0gMDtcbiAgICB0aGlzLl9yZXNwb25zZUNhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMuX2RlY29kZXIub24oJ2RhdGEnLCB0aGlzLl9oYW5kbGVEYXRhLmJpbmQodGhpcykpO1xuICB9XG5cbiAgX2hhbmRsZURhdGEgKGRhdGEpIHtcbiAgICBjb25zdCBjYiA9IHRoaXMuX3Jlc3BvbnNlQ2FsbGJhY2tzW2RhdGEuaGVhZGVyLnRhZ10gfHwgXy5ub29wO1xuICAgIGNiKGRhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLWNhbGxiYWNrc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEJVSUQgb2YgdGhlIGhvc3QgY29tcHV0ZXIgZnJvbSB1c2JtdXhkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dD01MDAwXSB0aGUgdGltZW91dCBvZiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHVzYm11eGRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGFzeW5jIHJlYWRCVUlEICh0aW1lb3V0ID0gNTAwMCkge1xuICAgIGNvbnN0IHt0YWcsIHJlY2VpdmVQcm9taXNlfSA9IHRoaXMuX3JlY2VpdmVQbGlzdFByb21pc2UodGltZW91dCwgKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLnBheWxvYWQuQlVJRCkge1xuICAgICAgICByZXR1cm4gZGF0YS5wYXlsb2FkLkJVSUQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3NlbmRQbGlzdCh7XG4gICAgICB0YWcsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIE1lc3NhZ2VUeXBlOiAnUmVhZEJVSUQnLFxuICAgICAgICBQcm9nTmFtZTogUFJPR19OQU1FLFxuICAgICAgICBDbGllbnRWZXJzaW9uU3RyaW5nOiBDTElFTlRfVkVSU0lPTl9TVFJJTkdcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCByZWNlaXZlUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgcGFpciByZWNvcmQgb2YgYSBkZXZpY2UuIEl0IHdpbGwgcmV0dXJuIG51bGwgaWYgaXQgZG9lc24ndCBleGlzdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgdGhlIHVkaWQgb2YgdGhlIGRldmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXQ9NTAwMF0gdGhlIHRpbWVvdXQgb2YgcmVjZWl2aW5nIGEgcmVzcG9uc2UgZnJvbSB1c2JtdXhkXG4gICAqIEByZXR1cm5zIHs/T2JqZWN0fVxuICAgKi9cbiAgYXN5bmMgcmVhZFBhaXJSZWNvcmQgKHVkaWQsIHRpbWVvdXQgPSA1MDAwKSB7XG4gICAgY29uc3Qge3RhZywgcmVjZWl2ZVByb21pc2V9ID0gdGhpcy5fcmVjZWl2ZVBsaXN0UHJvbWlzZSh0aW1lb3V0LCAoZGF0YSkgPT4ge1xuICAgICAgaWYgKCFkYXRhLnBheWxvYWQuUGFpclJlY29yZERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcGxpc3QucGFyc2VQbGlzdChkYXRhLnBheWxvYWQuUGFpclJlY29yZERhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VuZFBsaXN0KHtcbiAgICAgIHRhZyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgTWVzc2FnZVR5cGU6ICdSZWFkUGFpclJlY29yZCcsXG4gICAgICAgIFBhaXJSZWNvcmRJRDogdWRpZCxcbiAgICAgICAgUHJvZ05hbWU6IFBST0dfTkFNRSxcbiAgICAgICAgQ2xpZW50VmVyc2lvblN0cmluZzogQ0xJRU5UX1ZFUlNJT05fU1RSSU5HXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlY2VpdmVQcm9taXNlO1xuICB9XG5cbiAgX3NlbmRQbGlzdCAoanNvbikge1xuICAgIHRoaXMuX2VuY29kZXIud3JpdGUoanNvbik7XG4gIH1cblxuICBfcmVjZWl2ZVBsaXN0UHJvbWlzZSAodGltZW91dCA9IDUwMDAsIHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLl90YWcrKztcbiAgICBjb25zdCByZWNlaXZlUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlQ2FsbGJhY2tzW3RhZ10gPSAoZGF0YSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc29sdmUocmVzcG9uc2VDYWxsYmFjayhkYXRhKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byByZWNlaXZlIGFueSBkYXRhIHdpdGhpbiB0aGUgdGltZW91dDogJHt0aW1lb3V0fWApKSwgdGltZW91dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHt0YWcsIHJlY2VpdmVQcm9taXNlfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgZGV2aWNlcyBjb25uZWN0ZWQgdG8gdGhlIGhvc3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0PTUwMDBdIHRoZSB0aW1lb3V0IG9mIHJlY2VpdmluZyBhIHJlc3BvbnNlIGZyb20gdXNibXV4ZFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBhc3luYyBsaXN0RGV2aWNlcyAodGltZW91dCA9IDUwMDApIHtcbiAgICBjb25zdCB7dGFnLCByZWNlaXZlUHJvbWlzZX0gPSB0aGlzLl9yZWNlaXZlUGxpc3RQcm9taXNlKHRpbWVvdXQsIChkYXRhKSA9PiB7XG4gICAgICBpZiAoZGF0YS5wYXlsb2FkLkRldmljZUxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEucGF5bG9hZC5EZXZpY2VMaXN0O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZW5kUGxpc3Qoe1xuICAgICAgdGFnLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBNZXNzYWdlVHlwZTogJ0xpc3REZXZpY2VzJyxcbiAgICAgICAgUHJvZ05hbWU6IFBST0dfTkFNRSxcbiAgICAgICAgQ2xpZW50VmVyc2lvblN0cmluZzogQ0xJRU5UX1ZFUlNJT05fU1RSSU5HXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXdhaXQgcmVjZWl2ZVByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogTG9va3MgZm9yIGEgZGV2aWNlIHdpdGggdGhlIHBhc3NlZCB1ZGlkLiBJdCB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhlIGRldmljZSBpcyBub3QgZm91bmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgdGhlIHVkaWQgb2YgdGhlIGRldmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXQ9NTAwMF0gdGhlIHRpbWVvdXQgb2YgcmVjZWl2aW5nIGEgcmVzcG9uc2UgZnJvbSB1c2JtdXhkXG4gICAqIEByZXR1cm5zIHs/T2JqZWN0fVxuICAgKi9cbiAgYXN5bmMgZmluZERldmljZSAodWRpZCwgdGltZW91dCA9IDUwMDApIHtcbiAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgdGhpcy5saXN0RGV2aWNlcyh0aW1lb3V0KTtcbiAgICByZXR1cm4gXy5maW5kKGRldmljZXMsIChkZXZpY2UpID0+IGRldmljZS5Qcm9wZXJ0aWVzLlNlcmlhbE51bWJlciA9PT0gdWRpZCk7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gdGhlIGxvY2tkb3duZCBvbiB0aGUgZGV2aWNlIGFuZCByZXR1cm5zIGEgTG9ja2Rvd24gY2xpZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIHRoZSB1ZGlkIG9mIHRoZSBkZXZpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0PTUwMDBdIHRoZSB0aW1lb3V0IG9mIHJlY2VpdmluZyBhIHJlc3BvbnNlIGZyb20gdXNibXV4ZFxuICAgKiBAcmV0dXJucyB7TG9ja2Rvd259XG4gICAqL1xuICBhc3luYyBjb25uZWN0TG9ja2Rvd24gKHVkaWQsIHRpbWVvdXQgPSA1MDAwKSB7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdGhpcy5maW5kRGV2aWNlKHVkaWQsIHRpbWVvdXQpO1xuICAgIGlmICghZGV2aWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHRoZSBleHBlY3RlZCBkZXZpY2UgJyR7dWRpZH0nYCk7XG4gICAgfVxuICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IHRoaXMuY29ubmVjdChkZXZpY2UuUHJvcGVydGllcy5EZXZpY2VJRCwgTE9DS0RPV05fUE9SVCwgdGltZW91dCk7XG4gICAgcmV0dXJuIG5ldyBMb2NrZG93bihuZXcgUGxpc3RTZXJ2aWNlKHNvY2tldCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIGEgY2VydGFpbiBwb3J0IG9uIHRoZSBkZXZpY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlEIHRoZSBkZXZpY2UgaWQgd2hpY2ggY2FuIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBwcm9wZXJ0aWVzIG9mIGEgZGV2aWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0IHRoZSBwb3J0IG51bWJlciB0aGF0IHdhbnRzIHRvIGJlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXQ9NTAwMF0gdGhlIHRpbWVvdXQgb2YgcmVjZWl2aW5nIGEgcmVzcG9uc2UgZnJvbSB1c2JtdXhkXG4gICAqIEByZXR1cm5zIHtuZXQuU29ja2V0fE9iamVjdH0gVGhlIHNvY2tldCBvciB0aGUgb2JqZWN0IHJldHVybmVkIGluIHRoZSBjYWxsYmFjayBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhpc3RzXG4gICAqL1xuICBhc3luYyBjb25uZWN0IChkZXZpY2VJRCwgcG9ydCwgdGltZW91dCA9IDUwMDApIHtcbiAgICBjb25zdCB7dGFnLCByZWNlaXZlUHJvbWlzZX0gPSB0aGlzLl9yZWNlaXZlUGxpc3RQcm9taXNlKHRpbWVvdXQsIChkYXRhKSA9PiB7XG4gICAgICBpZiAoZGF0YS5wYXlsb2FkLk1lc3NhZ2VUeXBlICE9PSAnUmVzdWx0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnBheWxvYWQuTnVtYmVyID09PSBVU0JNVVhfUkVTVUxULk9LKSB7XG4gICAgICAgIHRoaXMuX3NwbGl0dGVyLnNodXRkb3duKCk7XG4gICAgICAgIHRoaXMuX3NvY2tldENsaWVudC51bnBpcGUodGhpcy5fc3BsaXR0ZXIpO1xuICAgICAgICB0aGlzLl9zcGxpdHRlci51bnBpcGUodGhpcy5fZGVjb2Rlcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb2NrZXRDbGllbnQ7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEucGF5bG9hZC5OdW1iZXIgPT09IFVTQk1VWF9SRVNVTFQuQ09OTlJFRlVTRUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIHdhcyByZWZ1c2VkIHRvIHBvcnQgJHtwb3J0fWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZW5kUGxpc3Qoe1xuICAgICAgdGFnLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBNZXNzYWdlVHlwZTogJ0Nvbm5lY3QnLFxuICAgICAgICBQcm9nTmFtZTogUFJPR19OQU1FLFxuICAgICAgICBDbGllbnRWZXJzaW9uU3RyaW5nOiBDTElFTlRfVkVSU0lPTl9TVFJJTkcsXG4gICAgICAgIERldmljZUlEOiBkZXZpY2VJRCxcbiAgICAgICAgUG9ydE51bWJlcjogc3dhcDE2KHBvcnQpXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXdhaXQgcmVjZWl2ZVByb21pc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgVXNibXV4LCBnZXREZWZhdWx0U29ja2V0IH07XG5leHBvcnQgZGVmYXVsdCBVc2JtdXg7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNB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