"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearInternalCache = clearInternalCache;
exports.getAutomationTraceTemplatePath = void 0;
exports.getAutomationTraceTemplatePathWithoutRetry = getAutomationTraceTemplatePathWithoutRetry;
exports.getClangVersion = getClangVersion;
exports.getCommandLineToolsVersion = getCommandLineToolsVersion;
exports.getConnectedDevices = getConnectedDevices;
exports.getMaxIOSSDK = exports.getInstrumentsPath = void 0;
exports.getMaxIOSSDKWithoutRetry = getMaxIOSSDKWithoutRetry;
exports.getMaxTVOSSDK = void 0;
exports.getMaxTVOSSDKWithoutRetry = getMaxTVOSSDKWithoutRetry;
exports.getPath = void 0;
exports.getVersion = getVersion;

require("source-map-support/register");

var _support = require("@appium/support");

var _path = _interopRequireDefault(require("path"));

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _plist = require("plist");

var _teen_process = require("teen_process");

var _semver = _interopRequireDefault(require("semver"));

const env = process.env;
const XCRUN_TIMEOUT = 15000;
const XCODE_SUBDIR = '/Contents/Developer';
const DEFAULT_NUMBER_OF_RETRIES = 3;

const log = _support.logger.getLogger('Xcode');

function hasExpectedSubDir(path) {
  return path.substring(path.length - XCODE_SUBDIR.length) === XCODE_SUBDIR;
}

async function runXcrunCommand(args, timeout = XCRUN_TIMEOUT) {
  try {
    const res = await (0, _teen_process.exec)('xcrun', args, {
      timeout
    });

    if (_lodash.default.isUndefined(res)) {
      throw new Error(`Nothing returned from trying to run 'xcrun ${args.join(' ')}'`);
    }

    return res;
  } catch (err) {
    if (err.stderr) {
      err.message = `${err.message}: ${err.stderr}`;
    }

    throw err;
  }
}

async function getPathFromSymlink(failMessage) {
  log.warn(`Finding XcodePath by symlink because ${failMessage}`);
  const symlinkPath = '/var/db/xcode_select_link';
  const legacySymlinkPath = '/usr/share/xcode-select/xcode_dir_link';
  let xcodePath = null;

  if (_support.util.hasContent(env.DEVELOPER_DIR)) {
    const customPath = hasExpectedSubDir(env.DEVELOPER_DIR) ? env.DEVELOPER_DIR : env.DEVELOPER_DIR + XCODE_SUBDIR;

    if (await _support.fs.exists(customPath)) {
      xcodePath = customPath;
    } else {
      let mesg = `Could not find path to Xcode, environment variable ` + `DEVELOPER_DIR set to: ${env.DEVELOPER_DIR} ` + `but no Xcode found`;
      log.warn(mesg);
      throw new Error(mesg);
    }
  } else if (await _support.fs.exists(symlinkPath)) {
    xcodePath = await _support.fs.readlink(symlinkPath);
  } else if (await _support.fs.exists(legacySymlinkPath)) {
    xcodePath = await _support.fs.readlink(legacySymlinkPath);
  }

  if (xcodePath) {
    return xcodePath.replace(new RegExp('/$'), '').trim();
  }

  let msg = `Could not find path to Xcode by symlinks located in ${symlinkPath}, or ${legacySymlinkPath}`;
  log.warn(msg);
  throw new Error(msg);
}

async function getPathFromXcodeSelect(timeout = XCRUN_TIMEOUT) {
  let {
    stdout
  } = await (0, _teen_process.exec)('xcode-select', ['--print-path'], {
    timeout
  });
  const xcodeFolderPath = stdout.replace(/\/$/, '').trim();

  if (!_support.util.hasContent(xcodeFolderPath)) {
    log.errorAndThrow('xcode-select returned an empty string');
  }

  if (await _support.fs.exists(xcodeFolderPath)) {
    return xcodeFolderPath;
  } else {
    const msg = `xcode-select could not find xcode. Path '${xcodeFolderPath}' does not exist.`;
    log.errorAndThrow(msg);
  }
}

const getPath = _lodash.default.memoize(function getPath(timeout = XCRUN_TIMEOUT) {
  return (async () => {
    try {
      return await getPathFromXcodeSelect(timeout);
    } catch (e) {
      return await getPathFromSymlink(e.message);
    }
  })();
});

exports.getPath = getPath;

async function getVersionWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const xcodePath = await getPath(timeout);

  const plistPath = _path.default.resolve(xcodePath, '..', 'Info.plist');

  if (!(await _support.fs.exists(plistPath))) {
    throw new Error(`Could not get Xcode version. ${plistPath} does not exist on disk.`);
  }

  const version = await _support.plist.parsePlistFile(plistPath);
  return _semver.default.coerce(version.CFBundleShortVersionString);
}

const getVersionMemoized = _lodash.default.memoize(function getVersionMemoized(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getVersionWithoutRetry, timeout);
});

async function getVersion(parse = false, retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  const version = await getVersionMemoized(retries, timeout);
  const versionString = version.patch > 0 ? version.version : `${version.major}.${version.minor}`;

  if (!parse) {
    return versionString;
  }

  return {
    versionString,
    versionFloat: parseFloat(versionString),
    major: version.major,
    minor: version.minor,
    patch: version.patch > 0 ? version.patch : undefined,

    toString() {
      return versionString;
    }

  };
}

async function getCommandLineToolsVersion() {
  const getVersionFunctions = [async () => {
    let pkg = (await (0, _teen_process.exec)('pkgutil', ['--pkgs=com.apple.pkg.DevSDK_.*'])).stdout;
    return (await (0, _teen_process.exec)('pkgutil', [`--pkg-info=${pkg.trim()}`])).stdout;
  }, async () => (await (0, _teen_process.exec)('pkgutil', [`--pkg-info=com.apple.pkg.CLTools_Executables`])).stdout, async () => (await (0, _teen_process.exec)('pkgutil', [`--pkg-info=com.apple.pkg.DeveloperToolsCLI`])).stdout];
  let stdout;

  for (let getVersion of getVersionFunctions) {
    try {
      stdout = await getVersion();
      break;
    } catch (ign) {
      stdout = '';
    }
  }

  let match = /^version: (.+)$/m.exec(stdout);
  return match ? match[1] : undefined;
}

async function getClangVersion() {
  try {
    await _support.fs.which('clang');
  } catch (e) {
    log.info('Cannot find clang executable on the local system. ' + 'Are Xcode Command Line Tools installed?');
    return null;
  }

  const {
    stdout
  } = await (0, _teen_process.exec)('clang', ['--version']);
  const match = /clang-([0-9.]+)/.exec(stdout);

  if (!match) {
    log.info(`Cannot parse clang version from ${stdout}`);
    return null;
  }

  return match[1];
}

async function getAutomationTraceTemplatePathWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const xcodePath = await getPath(timeout);
  const extensions = ['xrplugin', 'bundle'];

  const pathPrefix = _path.default.resolve(xcodePath, '../Applications/Instruments.app/Contents/PlugIns');

  const pathSuffix = 'Contents/Resources/Automation.tracetemplate';
  let automationTraceTemplatePaths = [_path.default.resolve(pathPrefix, `AutomationInstrument.${extensions[0]}`, pathSuffix), _path.default.resolve(pathPrefix, `AutomationInstrument.${extensions[1]}`, pathSuffix)];

  if (await _support.fs.exists(automationTraceTemplatePaths[0])) {
    return automationTraceTemplatePaths[0];
  }

  if (await _support.fs.exists(automationTraceTemplatePaths[1])) {
    return automationTraceTemplatePaths[1];
  }

  const msg = 'Could not find Automation.tracetemplate in any of the following' + `locations ${automationTraceTemplatePaths.toString()}`;
  log.error(msg);
  throw new Error(msg);
}

const getAutomationTraceTemplatePath = _lodash.default.memoize(function getAutomationTraceTemplatePath(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getAutomationTraceTemplatePathWithoutRetry, timeout);
});

exports.getAutomationTraceTemplatePath = getAutomationTraceTemplatePath;

async function getMaxIOSSDKWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const version = await getVersion(false, DEFAULT_NUMBER_OF_RETRIES, timeout);

  if (version[0] === '4') {
    return '6.1';
  }

  const args = ['--sdk', 'iphonesimulator', '--show-sdk-version'];
  const {
    stdout
  } = await runXcrunCommand(args, timeout);
  const sdkVersion = stdout.trim();
  const match = /\d.\d/.exec(stdout);

  if (!match) {
    throw new Error(`xcrun returned a non-numeric iOS SDK version: '${sdkVersion}'`);
  }

  return sdkVersion;
}

async function getMaxIOSSDKFromXcodeVersion(timeout = XCRUN_TIMEOUT) {
  const version = await getVersion(true, DEFAULT_NUMBER_OF_RETRIES, timeout);
  return `${version.major + 2}.${version.minor}`;
}

const getMaxIOSSDK = _lodash.default.memoize(function getMaxIOSSDK(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  try {
    return (0, _asyncbox.retry)(retries, getMaxIOSSDKWithoutRetry, timeout);
  } catch (err) {
    log.warn(`Unable to retrieve maximum iOS version: ${err.message}`);
    log.warn('Guessing from Xcode version');
    return getMaxIOSSDKFromXcodeVersion(timeout);
  }
});

exports.getMaxIOSSDK = getMaxIOSSDK;

async function getMaxTVOSSDKWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const args = ['--sdk', 'appletvsimulator', '--show-sdk-version'];
  const {
    stdout
  } = await runXcrunCommand(args, timeout);
  const sdkVersion = stdout.trim();

  if (isNaN(parseFloat(sdkVersion))) {
    throw new Error(`xcrun returned a non-numeric tvOS SDK version: '${sdkVersion}'`);
  }

  return sdkVersion;
}

const getMaxTVOSSDK = _lodash.default.memoize(function getMaxTVOSSDK(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getMaxTVOSSDKWithoutRetry, timeout);
});

exports.getMaxTVOSSDK = getMaxTVOSSDK;

async function getConnectedDevices(timeout = XCRUN_TIMEOUT) {
  const cmd = '/usr/sbin/system_profiler';
  const args = ['-xml', 'SPUSBDataType'];
  let {
    stdout
  } = await (0, _teen_process.exec)(cmd, args, {
    timeout
  });
  let plistContent = (0, _plist.parse)(stdout);
  let devicesFound = [];
  let entriesToSearch = [plistContent[0]];

  while (entriesToSearch.length > 0) {
    let currentEntry = entriesToSearch.pop();

    if (currentEntry instanceof Array) {
      entriesToSearch = entriesToSearch.concat(currentEntry);
    } else if (currentEntry._name && currentEntry._name.substring(0, 4) === 'iPad' || currentEntry._name && currentEntry._name.substring(0, 6) === 'iPhone' || currentEntry._name && _lodash.default.includes(currentEntry._name, 'Apple TV')) {
      let deviceInfo = {
        name: currentEntry._name,
        udid: currentEntry.serial_num,
        productId: currentEntry.product_id,
        deviceVersion: currentEntry.bcd_device
      };
      devicesFound.push(deviceInfo);
    } else if (currentEntry._items) {
      entriesToSearch = entriesToSearch.concat(currentEntry._items);
    }
  }

  return devicesFound;
}

async function getInstrumentsPathWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const args = ['-find', 'instruments'];
  let {
    stdout
  } = await runXcrunCommand(args, timeout);

  if (!stdout) {
    stdout = '';
  }

  let instrumentsPath = stdout.trim();

  if (!instrumentsPath) {
    throw new Error(`Could not find path to instruments binary using 'xcrun ${args.join(' ')}'`);
  }

  return instrumentsPath;
}

const getInstrumentsPath = _lodash.default.memoize(function getInstrumentsPath(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getInstrumentsPathWithoutRetry, timeout);
});

exports.getInstrumentsPath = getInstrumentsPath;

function clearInternalCache() {
  const memoized = [getPath, getVersionMemoized, getAutomationTraceTemplatePath, getMaxIOSSDK, getMaxTVOSSDK, getInstrumentsPath];
  memoized.forEach(f => {
    if (f.cache) {
      f.cache = new _lodash.default.memoize.Cache();
    }
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJlbnYiLCJwcm9jZXNzIiwiWENSVU5fVElNRU9VVCIsIlhDT0RFX1NVQkRJUiIsIkRFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMiLCJsb2ciLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJoYXNFeHBlY3RlZFN1YkRpciIsInBhdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJydW5YY3J1bkNvbW1hbmQiLCJhcmdzIiwidGltZW91dCIsInJlcyIsImV4ZWMiLCJfIiwiaXNVbmRlZmluZWQiLCJFcnJvciIsImpvaW4iLCJlcnIiLCJzdGRlcnIiLCJtZXNzYWdlIiwiZ2V0UGF0aEZyb21TeW1saW5rIiwiZmFpbE1lc3NhZ2UiLCJ3YXJuIiwic3ltbGlua1BhdGgiLCJsZWdhY3lTeW1saW5rUGF0aCIsInhjb2RlUGF0aCIsInV0aWwiLCJoYXNDb250ZW50IiwiREVWRUxPUEVSX0RJUiIsImN1c3RvbVBhdGgiLCJmcyIsImV4aXN0cyIsIm1lc2ciLCJyZWFkbGluayIsInJlcGxhY2UiLCJSZWdFeHAiLCJ0cmltIiwibXNnIiwiZ2V0UGF0aEZyb21YY29kZVNlbGVjdCIsInN0ZG91dCIsInhjb2RlRm9sZGVyUGF0aCIsImVycm9yQW5kVGhyb3ciLCJnZXRQYXRoIiwibWVtb2l6ZSIsImUiLCJnZXRWZXJzaW9uV2l0aG91dFJldHJ5IiwicGxpc3RQYXRoIiwicmVzb2x2ZSIsInZlcnNpb24iLCJwbGlzdCIsInBhcnNlUGxpc3RGaWxlIiwic2VtdmVyIiwiY29lcmNlIiwiQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmciLCJnZXRWZXJzaW9uTWVtb2l6ZWQiLCJyZXRyaWVzIiwicmV0cnkiLCJnZXRWZXJzaW9uIiwicGFyc2UiLCJ2ZXJzaW9uU3RyaW5nIiwicGF0Y2giLCJtYWpvciIsIm1pbm9yIiwidmVyc2lvbkZsb2F0IiwicGFyc2VGbG9hdCIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwiZ2V0Q29tbWFuZExpbmVUb29sc1ZlcnNpb24iLCJnZXRWZXJzaW9uRnVuY3Rpb25zIiwicGtnIiwiaWduIiwibWF0Y2giLCJnZXRDbGFuZ1ZlcnNpb24iLCJ3aGljaCIsImluZm8iLCJnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnkiLCJleHRlbnNpb25zIiwicGF0aFByZWZpeCIsInBhdGhTdWZmaXgiLCJhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzIiwiZXJyb3IiLCJnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgiLCJnZXRNYXhJT1NTREtXaXRob3V0UmV0cnkiLCJzZGtWZXJzaW9uIiwiZ2V0TWF4SU9TU0RLRnJvbVhjb2RlVmVyc2lvbiIsImdldE1heElPU1NESyIsImdldE1heFRWT1NTREtXaXRob3V0UmV0cnkiLCJpc05hTiIsImdldE1heFRWT1NTREsiLCJnZXRDb25uZWN0ZWREZXZpY2VzIiwiY21kIiwicGxpc3RDb250ZW50IiwicGFyc2VQbGlzdERhdGEiLCJkZXZpY2VzRm91bmQiLCJlbnRyaWVzVG9TZWFyY2giLCJjdXJyZW50RW50cnkiLCJwb3AiLCJBcnJheSIsImNvbmNhdCIsIl9uYW1lIiwiaW5jbHVkZXMiLCJkZXZpY2VJbmZvIiwibmFtZSIsInVkaWQiLCJzZXJpYWxfbnVtIiwicHJvZHVjdElkIiwicHJvZHVjdF9pZCIsImRldmljZVZlcnNpb24iLCJiY2RfZGV2aWNlIiwicHVzaCIsIl9pdGVtcyIsImdldEluc3RydW1lbnRzUGF0aFdpdGhvdXRSZXRyeSIsImluc3RydW1lbnRzUGF0aCIsImdldEluc3RydW1lbnRzUGF0aCIsImNsZWFySW50ZXJuYWxDYWNoZSIsIm1lbW9pemVkIiwiZm9yRWFjaCIsImYiLCJjYWNoZSIsIkNhY2hlIl0sInNvdXJjZXMiOlsiLi4vLi4vbGliL3hjb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHV0aWwsIGZzLCBwbGlzdCwgbG9nZ2VyIH0gZnJvbSAnQGFwcGl1bS9zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcmV0cnkgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VQbGlzdERhdGEgfSBmcm9tICdwbGlzdCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudjtcblxuY29uc3QgWENSVU5fVElNRU9VVCA9IDE1MDAwO1xuY29uc3QgWENPREVfU1VCRElSID0gJy9Db250ZW50cy9EZXZlbG9wZXInO1xuY29uc3QgREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUyA9IDM7XG5cbmNvbnN0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ1hjb2RlJyk7XG5cblxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRTdWJEaXIgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKHBhdGgubGVuZ3RoIC0gWENPREVfU1VCRElSLmxlbmd0aCkgPT09IFhDT0RFX1NVQkRJUjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuWGNydW5Db21tYW5kIChhcmdzLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGV4ZWMoJ3hjcnVuJywgYXJncywge3RpbWVvdXR9KTtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChyZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdGhpbmcgcmV0dXJuZWQgZnJvbSB0cnlpbmcgdG8gcnVuICd4Y3J1biAke2FyZ3Muam9pbignICcpfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gdGhlIHRydWUgZXJyb3IgY2FuIGJlIGhpZGRlbiB3aXRoaW4gdGhlIHN0ZGVyclxuICAgIGlmIChlcnIuc3RkZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfTogJHtlcnIuc3RkZXJyfWA7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFBhdGhGcm9tU3ltbGluayAoZmFpbE1lc3NhZ2UpIHtcbiAgLy8gTm9kZSdzIGludm9jYXRpb24gb2YgeGNvZGUtc2VsZWN0IHNvbWV0aW1lcyBmbGFrZXMgYW5kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAvLyBOb3QgY2xlYXIgd2h5LiBBcyBhIHdvcmthcm91bmQsIEFwcGl1bSBjYW4gcmVsaWFibHkgZGVkdWNlIHRoZSB2ZXJzaW9uIGluIHVzZSBieSBjaGVja2luZ1xuICAvLyB0aGUgbG9jYXRpb25zIHhjb2RlLXNlbGVjdCB1c2VzIHRvIHN0b3JlIHRoZSBzZWxlY3RlZCB2ZXJzaW9uJ3MgcGF0aC4gVGhpcyBzaG91bGQgYmUgMTAwJVxuICAvLyByZWxpYWJsZSBzbyBsb25nIGFzIHRoZSBsaW5rIGxvY2F0aW9ucyByZW1haW4gdGhlIHNhbWUuIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIHJlbHlpbmcgb25cbiAgLy8gaGFyZGNvZGVkIHBhdGhzLCB0aGlzIGFwcHJvYWNoIHdpbGwgYnJlYWsgdGhlIG5leHQgdGltZSBBcHBsZSBjaGFuZ2VzIHRoZSBzeW1saW5rIGxvY2F0aW9uLlxuICBsb2cud2FybihgRmluZGluZyBYY29kZVBhdGggYnkgc3ltbGluayBiZWNhdXNlICR7ZmFpbE1lc3NhZ2V9YCk7XG5cbiAgY29uc3Qgc3ltbGlua1BhdGggPSAnL3Zhci9kYi94Y29kZV9zZWxlY3RfbGluayc7XG4gIGNvbnN0IGxlZ2FjeVN5bWxpbmtQYXRoID0gJy91c3Ivc2hhcmUveGNvZGUtc2VsZWN0L3hjb2RlX2Rpcl9saW5rJzsgLy8gIFhjb2RlIDwgNS54XG4gIGxldCB4Y29kZVBhdGggPSBudWxsO1xuXG4gIC8vIHhjb2RlLXNlbGVjdCBhbGxvd3MgdXNlcnMgdG8gb3ZlcnJpZGUgaXRzIHNldHRpbmdzIHdpdGggdGhlIERFVkVMT1BFUl9ESVIgZW52IHZhcixcbiAgLy8gc28gY2hlY2sgdGhhdCBmaXJzdFxuICBpZiAodXRpbC5oYXNDb250ZW50KGVudi5ERVZFTE9QRVJfRElSKSkge1xuICAgIGNvbnN0IGN1c3RvbVBhdGggPSBoYXNFeHBlY3RlZFN1YkRpcihlbnYuREVWRUxPUEVSX0RJUilcbiAgICAgID8gZW52LkRFVkVMT1BFUl9ESVJcbiAgICAgIDogZW52LkRFVkVMT1BFUl9ESVIgKyBYQ09ERV9TVUJESVI7XG5cbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGN1c3RvbVBhdGgpKSB7XG4gICAgICB4Y29kZVBhdGggPSBjdXN0b21QYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWVzZyA9IGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIFhjb2RlLCBlbnZpcm9ubWVudCB2YXJpYWJsZSBgICtcbiAgICAgICAgICAgICAgICAgYERFVkVMT1BFUl9ESVIgc2V0IHRvOiAke2Vudi5ERVZFTE9QRVJfRElSfSBgICtcbiAgICAgICAgICAgICAgICAgYGJ1dCBubyBYY29kZSBmb3VuZGA7XG4gICAgICBsb2cud2FybihtZXNnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXdhaXQgZnMuZXhpc3RzKHN5bWxpbmtQYXRoKSkge1xuICAgIHhjb2RlUGF0aCA9IGF3YWl0IGZzLnJlYWRsaW5rKHN5bWxpbmtQYXRoKTtcbiAgfSBlbHNlIGlmIChhd2FpdCBmcy5leGlzdHMobGVnYWN5U3ltbGlua1BhdGgpKSB7XG4gICAgeGNvZGVQYXRoID0gYXdhaXQgZnMucmVhZGxpbmsobGVnYWN5U3ltbGlua1BhdGgpO1xuICB9XG5cbiAgaWYgKHhjb2RlUGF0aCkge1xuICAgIHJldHVybiB4Y29kZVBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCcvJCcpLCAnJykudHJpbSgpO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIG9ubHkgZ2V0IGhlcmUgaXMgd2UgZmFpbGVkIHRvIGNhcHR1cmUgeGNvZGUtc2VsZWN0J3Mgc3Rkb3V0IGFuZCBvdXJcbiAgLy8gb3RoZXIgY2hlY2tzIGZhaWxlZC4gRWl0aGVyIEFwcGxlIGhhcyBtb3ZlZCB0aGUgc3ltbGluayB0byBhIG5ldyBsb2NhdGlvbiBvciB0aGUgdXNlclxuICAvLyBpcyBub3QgdXNpbmcgdGhlIGRlZmF1bHQgaW5zdGFsbC4gOTkuOTk5JSBjaGFuY2UgaXQncyB0aGUgbGF0dGVyLCBzbyBpc3N1ZSBhIHdhcm5pbmdcbiAgLy8gc2hvdWxkIHdlIGV2ZXIgaGl0IHRoZSBlZGdlIGNhc2UuXG4gIGxldCBtc2cgPSBgQ291bGQgbm90IGZpbmQgcGF0aCB0byBYY29kZSBieSBzeW1saW5rcyBsb2NhdGVkIGluICR7c3ltbGlua1BhdGh9LCBvciAke2xlZ2FjeVN5bWxpbmtQYXRofWA7XG4gIGxvZy53YXJuKG1zZyk7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRQYXRoRnJvbVhjb2RlU2VsZWN0ICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCd4Y29kZS1zZWxlY3QnLCBbJy0tcHJpbnQtcGF0aCddLCB7dGltZW91dH0pO1xuXG4gIC8vIHRyaW0gYW5kIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICBjb25zdCB4Y29kZUZvbGRlclBhdGggPSBzdGRvdXQucmVwbGFjZSgvXFwvJC8sICcnKS50cmltKCk7XG5cbiAgaWYgKCF1dGlsLmhhc0NvbnRlbnQoeGNvZGVGb2xkZXJQYXRoKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KCd4Y29kZS1zZWxlY3QgcmV0dXJuZWQgYW4gZW1wdHkgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKHhjb2RlRm9sZGVyUGF0aCkpIHtcbiAgICByZXR1cm4geGNvZGVGb2xkZXJQYXRoO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IGB4Y29kZS1zZWxlY3QgY291bGQgbm90IGZpbmQgeGNvZGUuIFBhdGggJyR7eGNvZGVGb2xkZXJQYXRofScgZG9lcyBub3QgZXhpc3QuYDtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhtc2cpO1xuICB9XG59XG5cbmNvbnN0IGdldFBhdGggPSBfLm1lbW9pemUoZnVuY3Rpb24gZ2V0UGF0aCAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgLy8gZmlyc3Qgd2UgdHJ5IHVzaW5nIHhjb2RlLXNlbGVjdCB0byBmaW5kIHRoZSBwYXRoXG4gIC8vIHRoZW4gd2UgdHJ5IHVzaW5nIHRoZSBzeW1saW5rcyB0aGF0IEFwcGxlIGhhcyBieSBkZWZhdWx0XG4gIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0UGF0aEZyb21YY29kZVNlbGVjdCh0aW1lb3V0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0UGF0aEZyb21TeW1saW5rKGUubWVzc2FnZSk7XG4gICAgfVxuICB9KSgpO1xufSk7XG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCh0aW1lb3V0KTtcblxuICAvLyB3ZSB3YW50IHRvIHJlYWQgdGhlIENGQnVuZGxlU2hvcnRWZXJzaW9uU3RyaW5nIGZyb20gWGNvZGUncyBwbGlzdC5cbiAgLy8gSXQgc2hvdWxkIGJlIGluIC9bcm9vdF0vWENvZGUuYXBwL0NvbnRlbnRzL1xuICBjb25zdCBwbGlzdFBhdGggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCAnLi4nLCAnSW5mby5wbGlzdCcpO1xuXG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKHBsaXN0UGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBnZXQgWGNvZGUgdmVyc2lvbi4gJHtwbGlzdFBhdGh9IGRvZXMgbm90IGV4aXN0IG9uIGRpc2suYCk7XG4gIH1cblxuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgcGxpc3QucGFyc2VQbGlzdEZpbGUocGxpc3RQYXRoKTtcbiAgcmV0dXJuIHNlbXZlci5jb2VyY2UodmVyc2lvbi5DRkJ1bmRsZVNob3J0VmVyc2lvblN0cmluZyk7XG59XG5cbmNvbnN0IGdldFZlcnNpb25NZW1vaXplZCA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gZ2V0VmVyc2lvbk1lbW9pemVkIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb24gKHBhcnNlID0gZmFsc2UsIHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbk1lbW9pemVkKHJldHJpZXMsIHRpbWVvdXQpO1xuICAvLyB4Y29kZSB2ZXJzaW9uIHN0cmluZ3MgYXJlIG5vdCBleGFjdGx5IHNlbXZlciBzdHJpbmc6IHBhdGNoIHZlcnNpb25zIG9mIDBcbiAgLy8gYXJlIHJlbW92ZWQgKGUuZy4sICcxMC4wLjAnID0+ICcxMC4wJylcbiAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24ucGF0Y2ggPiAwID8gdmVyc2lvbi52ZXJzaW9uIDogYCR7dmVyc2lvbi5tYWpvcn0uJHt2ZXJzaW9uLm1pbm9yfWA7XG4gIGlmICghcGFyc2UpIHtcbiAgICByZXR1cm4gdmVyc2lvblN0cmluZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvblN0cmluZyxcbiAgICB2ZXJzaW9uRmxvYXQ6IHBhcnNlRmxvYXQodmVyc2lvblN0cmluZyksXG4gICAgbWFqb3I6IHZlcnNpb24ubWFqb3IsXG4gICAgbWlub3I6IHZlcnNpb24ubWlub3IsXG4gICAgcGF0Y2g6IHZlcnNpb24ucGF0Y2ggPiAwID8gdmVyc2lvbi5wYXRjaCA6IHVuZGVmaW5lZCxcbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdmVyc2lvblN0cmluZztcbiAgICB9LFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbiAoKSB7XG4gIC8vIHRoZXJlIGFyZSBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0aGF0IHRoZSBDTEkgdG9vbHMgdmVyc2lvbiBoYXMgYmVlblxuICAvLyByZXByZXNlbnRlZC4gVHJ5IHRoZW0gZnJvbSBtb3N0IHJlbGlhYmxlIHRvIGxlYXN0LCBmYWxsaW5nIGRvd24gdGhlIGNoYWluXG4gIGNvbnN0IGdldFZlcnNpb25GdW5jdGlvbnMgPSBbXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHBrZyA9IChhd2FpdCBleGVjKCdwa2d1dGlsJywgWyctLXBrZ3M9Y29tLmFwcGxlLnBrZy5EZXZTREtfLionXSkpLnN0ZG91dDtcbiAgICAgIHJldHVybiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz0ke3BrZy50cmltKCl9YF0pKS5zdGRvdXQ7XG4gICAgfSxcbiAgICBhc3luYyAoKSA9PiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkNMVG9vbHNfRXhlY3V0YWJsZXNgXSkpLnN0ZG91dCxcbiAgICBhc3luYyAoKSA9PiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkRldmVsb3BlclRvb2xzQ0xJYF0pKS5zdGRvdXQsXG4gIF07XG4gIGxldCBzdGRvdXQ7XG4gIGZvciAobGV0IGdldFZlcnNpb24gb2YgZ2V0VmVyc2lvbkZ1bmN0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBzdGRvdXQgPSBhd2FpdCBnZXRWZXJzaW9uKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgIHN0ZG91dCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIHN0ZG91dCBzaG91bGQgaGF2ZSBhIGxpbmUgbGlrZSBgdmVyc2lvbjogOC4wLjAuMC4xLjE0NzI0MzU4ODFgXG4gIGxldCBtYXRjaCA9IC9edmVyc2lvbjogKC4rKSQvbS5leGVjKHN0ZG91dCk7IC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvSFYzeDRkLzFcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaHR0cHM6Ly90cmFjLm1hY3BvcnRzLm9yZy93aWtpL1hjb2RlVmVyc2lvbkluZm9cbiAqIHRvIHNlZSB0aGUgYWN0dWFsIG1hcHBpbmcgYmV0d2VlbiBjbGFuZyBhbmQgb3RoZXIgY29tcG9uZW50cy5cbiAqXG4gKiBAcmV0dXJucyB7P3N0cmluZ30gVGhlIGFjdHVhbCBDbGFuZyB2ZXJzaW9uIGluIHgueC54Lnggb3IgeC54LnggZm9ybWF0LFxuICogd2hpY2ggaXMgc3VwcGxpZWQgd2l0aCBDb21tYW5kIExpbmUgVG9vbHMuIGBudWxsYCBpcyByZXR1cm5lZFxuICogaWYgQ0xUIGFyZSBub3QgaW5zdGFsbGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDbGFuZ1ZlcnNpb24gKCkge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndoaWNoKCdjbGFuZycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmluZm8oJ0Nhbm5vdCBmaW5kIGNsYW5nIGV4ZWN1dGFibGUgb24gdGhlIGxvY2FsIHN5c3RlbS4gJyArXG4gICAgICAnQXJlIFhjb2RlIENvbW1hbmQgTGluZSBUb29scyBpbnN0YWxsZWQ/Jyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdjbGFuZycsIFsnLS12ZXJzaW9uJ10pO1xuICBjb25zdCBtYXRjaCA9IC9jbGFuZy0oWzAtOS5dKykvLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIGxvZy5pbmZvKGBDYW5ub3QgcGFyc2UgY2xhbmcgdmVyc2lvbiBmcm9tICR7c3Rkb3V0fWApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBtYXRjaFsxXTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoV2l0aG91dFJldHJ5ICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCB4Y29kZVBhdGggPSBhd2FpdCBnZXRQYXRoKHRpbWVvdXQpO1xuXG4gIC8vIGZvciBpb3MgOCBhbmQgdXAsIHRoZSBmaWxlIGV4dGVuc2lvbiBmb3IgQXV0aW9tYXRpb25JbnN0cnVtZW50IGNoYW5nZWQuXG4gIC8vIHJhdGhlciB0aGFuIHdhc3RlIHRpbWUgZ2V0dGluZyB0aGUgaU9TU0RLVmVyc2lvbiwganVzdCBnZXQgYm90aCBwYXRocyBhbmQgc2VlIHdoaWNoIG9uZSBleGlzdHNcbiAgY29uc3QgZXh0ZW5zaW9ucyA9IFsneHJwbHVnaW4nLCAnYnVuZGxlJ107XG4gIGNvbnN0IHBhdGhQcmVmaXggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCAnLi4vQXBwbGljYXRpb25zL0luc3RydW1lbnRzLmFwcC9Db250ZW50cy9QbHVnSW5zJyk7XG4gIGNvbnN0IHBhdGhTdWZmaXggPSAnQ29udGVudHMvUmVzb3VyY2VzL0F1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZSc7XG4gIGxldCBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzID0gW1xuICAgIHBhdGgucmVzb2x2ZShwYXRoUHJlZml4LCBgQXV0b21hdGlvbkluc3RydW1lbnQuJHtleHRlbnNpb25zWzBdfWAsIHBhdGhTdWZmaXgpLFxuICAgIHBhdGgucmVzb2x2ZShwYXRoUHJlZml4LCBgQXV0b21hdGlvbkluc3RydW1lbnQuJHtleHRlbnNpb25zWzFdfWAsIHBhdGhTdWZmaXgpXG4gIF07XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzBdKSkge1xuICAgIHJldHVybiBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzBdO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzFdKSkge1xuICAgIHJldHVybiBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzFdO1xuICB9XG5cbiAgY29uc3QgbXNnID0gJ0NvdWxkIG5vdCBmaW5kIEF1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZSBpbiBhbnkgb2YgdGhlIGZvbGxvd2luZycgK1xuICAgICAgICAgICAgICBgbG9jYXRpb25zICR7YXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRocy50b1N0cmluZygpfWA7XG4gIGxvZy5lcnJvcihtc2cpO1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcblxufVxuXG5jb25zdCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGggPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHJldHJ5KHJldHJpZXMsIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE1heElPU1NES1dpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IGdldFZlcnNpb24oZmFsc2UsIERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQpO1xuICBpZiAodmVyc2lvblswXSA9PT0gJzQnKSB7XG4gICAgcmV0dXJuICc2LjEnO1xuICB9XG5cbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAnaXBob25lc2ltdWxhdG9yJywgJy0tc2hvdy1zZGstdmVyc2lvbiddO1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHJ1blhjcnVuQ29tbWFuZChhcmdzLCB0aW1lb3V0KTtcblxuICBjb25zdCBzZGtWZXJzaW9uID0gc3Rkb3V0LnRyaW0oKTtcbiAgY29uc3QgbWF0Y2ggPSAvXFxkLlxcZC8uZXhlYyhzdGRvdXQpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHhjcnVuIHJldHVybmVkIGEgbm9uLW51bWVyaWMgaU9TIFNESyB2ZXJzaW9uOiAnJHtzZGtWZXJzaW9ufSdgKTtcbiAgfVxuXG4gIHJldHVybiBzZGtWZXJzaW9uO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRNYXhJT1NTREtGcm9tWGNvZGVWZXJzaW9uICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbih0cnVlLCBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0KTtcbiAgLy8gYXMgb2Ygbm93LCB0aGUgaU9TIHZlcnNpb24gYXNzb2NpYXRlZCB3aXRoIGFuIFhjb2RlIHZlcnNpb24gaXNcbiAgLy8ganVzdCB0aGUgWGNvZGUgdmVyc2lvbiArIDJcbiAgcmV0dXJuIGAke3ZlcnNpb24ubWFqb3IgKyAyfS4ke3ZlcnNpb24ubWlub3J9YDtcbn1cblxuY29uc3QgZ2V0TWF4SU9TU0RLID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiBnZXRNYXhJT1NTREsgKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBVbmFibGUgdG8gcmV0cmlldmUgbWF4aW11bSBpT1MgdmVyc2lvbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIGxvZy53YXJuKCdHdWVzc2luZyBmcm9tIFhjb2RlIHZlcnNpb24nKTtcbiAgICAgIHJldHVybiBnZXRNYXhJT1NTREtGcm9tWGNvZGVWZXJzaW9uKHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TWF4VFZPU1NES1dpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAnYXBwbGV0dnNpbXVsYXRvcicsICctLXNob3ctc2RrLXZlcnNpb24nXTtcbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBydW5YY3J1bkNvbW1hbmQoYXJncywgdGltZW91dCk7XG5cbiAgY29uc3Qgc2RrVmVyc2lvbiA9IHN0ZG91dC50cmltKCk7XG5cbiAgaWYgKGlzTmFOKHBhcnNlRmxvYXQoc2RrVmVyc2lvbikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB4Y3J1biByZXR1cm5lZCBhIG5vbi1udW1lcmljIHR2T1MgU0RLIHZlcnNpb246ICcke3Nka1ZlcnNpb259J2ApO1xuICB9XG5cbiAgcmV0dXJuIHNka1ZlcnNpb247XG59XG5cbmNvbnN0IGdldE1heFRWT1NTREsgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIGdldE1heFRWT1NTREsgKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRNYXhUVk9TU0RLV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRGV2aWNlcyAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgY21kID0gJy91c3Ivc2Jpbi9zeXN0ZW1fcHJvZmlsZXInO1xuICBjb25zdCBhcmdzID0gWycteG1sJywgJ1NQVVNCRGF0YVR5cGUnXTtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIGFyZ3MsIHt0aW1lb3V0fSk7XG4gIGxldCBwbGlzdENvbnRlbnQgPSBwYXJzZVBsaXN0RGF0YShzdGRvdXQpO1xuXG4gIGxldCBkZXZpY2VzRm91bmQgPSBbXTtcbiAgbGV0IGVudHJpZXNUb1NlYXJjaCA9IFtwbGlzdENvbnRlbnRbMF1dO1xuICB3aGlsZSAoZW50cmllc1RvU2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgY3VycmVudEVudHJ5ID0gZW50cmllc1RvU2VhcmNoLnBvcCgpO1xuICAgIGlmIChjdXJyZW50RW50cnkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZW50cmllc1RvU2VhcmNoID0gZW50cmllc1RvU2VhcmNoLmNvbmNhdChjdXJyZW50RW50cnkpO1xuICAgIH0gZWxzZSBpZiAoKGN1cnJlbnRFbnRyeS5fbmFtZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbnRyeS5fbmFtZS5zdWJzdHJpbmcoMCwgNCkgPT09ICdpUGFkJykgfHxcbiAgICAgICAgICAgICAgIChjdXJyZW50RW50cnkuX25hbWUgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RW50cnkuX25hbWUuc3Vic3RyaW5nKDAsIDYpID09PSAnaVBob25lJykgfHxcbiAgICAgICAgICAgICAgIChjdXJyZW50RW50cnkuX25hbWUgJiYgXy5pbmNsdWRlcyhjdXJyZW50RW50cnkuX25hbWUsICdBcHBsZSBUVicpKSkge1xuICAgICAgbGV0IGRldmljZUluZm8gPSB7XG4gICAgICAgIG5hbWU6IGN1cnJlbnRFbnRyeS5fbmFtZSxcbiAgICAgICAgdWRpZDogY3VycmVudEVudHJ5LnNlcmlhbF9udW0sXG4gICAgICAgIHByb2R1Y3RJZDogY3VycmVudEVudHJ5LnByb2R1Y3RfaWQsXG4gICAgICAgIGRldmljZVZlcnNpb246IGN1cnJlbnRFbnRyeS5iY2RfZGV2aWNlXG4gICAgICB9O1xuICAgICAgZGV2aWNlc0ZvdW5kLnB1c2goZGV2aWNlSW5mbyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50RW50cnkuX2l0ZW1zKSB7XG4gICAgICBlbnRyaWVzVG9TZWFyY2ggPSBlbnRyaWVzVG9TZWFyY2guY29uY2F0KGN1cnJlbnRFbnRyeS5faXRlbXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGV2aWNlc0ZvdW5kO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRJbnN0cnVtZW50c1BhdGhXaXRob3V0UmV0cnkgKHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIGNvbnN0IGFyZ3MgPSBbJy1maW5kJywgJ2luc3RydW1lbnRzJ107XG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IHJ1blhjcnVuQ29tbWFuZChhcmdzLCB0aW1lb3V0KTtcblxuICBpZiAoIXN0ZG91dCkge1xuICAgIHN0ZG91dCA9ICcnO1xuICB9XG5cbiAgbGV0IGluc3RydW1lbnRzUGF0aCA9IHN0ZG91dC50cmltKCk7XG5cbiAgaWYgKCFpbnN0cnVtZW50c1BhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhdGggdG8gaW5zdHJ1bWVudHMgYmluYXJ5IHVzaW5nICd4Y3J1biAke2FyZ3Muam9pbignICcpfSdgKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0cnVtZW50c1BhdGg7XG59XG5cbmNvbnN0IGdldEluc3RydW1lbnRzUGF0aCA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gZ2V0SW5zdHJ1bWVudHNQYXRoIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0SW5zdHJ1bWVudHNQYXRoV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgfVxuKTtcblxuZnVuY3Rpb24gY2xlYXJJbnRlcm5hbENhY2hlICgpIHtcblxuICAvLyBtZW1vaXplZCBmdW5jdGlvbnNcbiAgY29uc3QgbWVtb2l6ZWQgPSBbXG4gICAgZ2V0UGF0aCwgZ2V0VmVyc2lvbk1lbW9pemVkLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgsIGdldE1heElPU1NESyxcbiAgICBnZXRNYXhUVk9TU0RLLCBnZXRJbnN0cnVtZW50c1BhdGgsXG4gIF07XG5cbiAgbWVtb2l6ZWQuZm9yRWFjaCgoZikgPT4ge1xuICAgIGlmIChmLmNhY2hlKSB7XG4gICAgICBmLmNhY2hlID0gbmV3IF8ubWVtb2l6ZS5DYWNoZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7XG4gIGdldFBhdGgsIGdldFZlcnNpb24sIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCwgZ2V0TWF4SU9TU0RLLFxuICBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnksIGdldE1heElPU1NES1dpdGhvdXRSZXRyeSxcbiAgZ2V0Q29ubmVjdGVkRGV2aWNlcywgY2xlYXJJbnRlcm5hbENhY2hlLCBnZXRJbnN0cnVtZW50c1BhdGgsXG4gIGdldENvbW1hbmRMaW5lVG9vbHNWZXJzaW9uLCBnZXRNYXhUVk9TU0RLLCBnZXRNYXhUVk9TU0RLV2l0aG91dFJldHJ5LFxuICBnZXRDbGFuZ1ZlcnNpb24sXG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0EsTUFBTUEsR0FBRyxHQUFHQyxPQUFPLENBQUNELEdBQXBCO0FBRUEsTUFBTUUsYUFBYSxHQUFHLEtBQXRCO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLHFCQUFyQjtBQUNBLE1BQU1DLHlCQUF5QixHQUFHLENBQWxDOztBQUVBLE1BQU1DLEdBQUcsR0FBR0MsZUFBQSxDQUFPQyxTQUFQLENBQWlCLE9BQWpCLENBQVo7O0FBR0EsU0FBU0MsaUJBQVQsQ0FBNEJDLElBQTVCLEVBQWtDO0VBQ2hDLE9BQU9BLElBQUksQ0FBQ0MsU0FBTCxDQUFlRCxJQUFJLENBQUNFLE1BQUwsR0FBY1IsWUFBWSxDQUFDUSxNQUExQyxNQUFzRFIsWUFBN0Q7QUFDRDs7QUFFRCxlQUFlUyxlQUFmLENBQWdDQyxJQUFoQyxFQUFzQ0MsT0FBTyxHQUFHWixhQUFoRCxFQUErRDtFQUM3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