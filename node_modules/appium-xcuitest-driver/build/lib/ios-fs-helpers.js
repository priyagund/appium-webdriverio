"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pullFile = pullFile;
exports.pullFolder = pullFolder;
exports.pushFile = pushFile;
exports.pushFolder = pushFolder;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _support = require("appium/support");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("./logger"));

const IO_TIMEOUT_MS = 4 * 60 * 1000;
const MAX_IO_CHUNK_SIZE = 8;

async function pullFile(afcService, remotePath) {
  const stream = await afcService.createReadStream(remotePath, {
    autoDestroy: true
  });
  const pullPromise = new _bluebird.default((resolve, reject) => {
    stream.on('close', resolve);
    stream.on('error', reject);
  }).timeout(IO_TIMEOUT_MS);
  const buffers = [];
  stream.on('data', data => buffers.push(data));
  await pullPromise;
  return Buffer.concat(buffers);
}

async function folderExists(folderPath) {
  try {
    return (await _support.fs.stat(folderPath)).isDirectory();
  } catch (e) {
    return false;
  }
}

async function pullFolder(afcService, remoteRootPath) {
  const tmpFolder = await _support.tempDir.openDir();

  try {
    let localTopItem = null;
    let countFilesSuccess = 0;
    let countFilesFail = 0;
    let countFolders = 0;
    const pullPromises = [];
    await afcService.walkDir(remoteRootPath, true, async (remotePath, isDir) => {
      const localPath = _path.default.join(tmpFolder, remotePath);

      const dirname = isDir ? localPath : _path.default.dirname(localPath);

      if (!(await folderExists(dirname))) {
        await (0, _support.mkdirp)(dirname);
      }

      if (!localTopItem || localPath.split(_path.default.sep).length < localTopItem.split(_path.default.sep).length) {
        localTopItem = localPath;
      }

      if (isDir) {
        ++countFolders;
        return;
      }

      const readStream = await afcService.createReadStream(remotePath, {
        autoDestroy: true
      });

      const writeStream = _support.fs.createWriteStream(localPath, {
        autoClose: true
      });

      pullPromises.push(new _bluebird.default(resolve => {
        writeStream.on('close', () => {
          ++countFilesSuccess;
          resolve();
        });

        const onStreamingError = e => {
          readStream.unpipe(writeStream);

          _logger.default.warn(`Cannot pull '${remotePath}' to '${localPath}'. ` + `The file will be skipped. Original error: ${e.message}`);

          ++countFilesFail;
          resolve();
        };

        writeStream.on('error', onStreamingError);
        readStream.on('error', onStreamingError);
      }).timeout(IO_TIMEOUT_MS));
      readStream.pipe(writeStream);

      if (pullPromises.length >= MAX_IO_CHUNK_SIZE) {
        await _bluebird.default.any(pullPromises);
      }

      _lodash.default.remove(pullPromises, p => p.isFulfilled());
    });

    if (!_lodash.default.isEmpty(pullPromises)) {
      await _bluebird.default.all(pullPromises);
    }

    _logger.default.info(`Pulled ${_support.util.pluralize('file', countFilesSuccess, true)} out of ` + `${countFilesSuccess + countFilesFail} and ${_support.util.pluralize('folder', countFolders, true)} ` + `from '${remoteRootPath}'`);

    return await _support.zip.toInMemoryZip(localTopItem ? _path.default.dirname(localTopItem) : tmpFolder, {
      encodeToBase64: true
    });
  } finally {
    await _support.fs.rimraf(tmpFolder);
  }
}

async function remoteMkdirp(afcService, remoteRoot) {
  if (remoteRoot === '.' || remoteRoot === '/') {
    return;
  }

  try {
    await afcService.listDirectory(remoteRoot);
    return;
  } catch (e) {
    await remoteMkdirp(afcService, _path.default.dirname(remoteRoot));
  }

  await afcService.createDirectory(remoteRoot);
}

async function pushFile(afcService, remotePath, base64Data) {
  await remoteMkdirp(afcService, _path.default.dirname(remotePath));
  const stream = await afcService.createWriteStream(remotePath, {
    autoDestroy: true
  });
  let pushError = null;
  const pushPromise = new _bluebird.default((resolve, reject) => {
    stream.on('error', e => {
      pushError = e;
    });
    stream.on('close', () => {
      if (pushError) {
        reject(pushError);
      } else {
        resolve();
      }
    });
  }).timeout(IO_TIMEOUT_MS);
  stream.write(Buffer.from(base64Data, 'base64'));
  stream.end();
  await pushPromise;
}

async function pushFolder(afcService, srcRootPath, dstRootPath, opts = {}) {
  const {
    timeoutMs = IO_TIMEOUT_MS,
    enableParallelPush = false
  } = opts;
  const timer = new _support.timing.Timer().start();
  const itemsToPush = await _support.fs.glob('**', {
    cwd: srcRootPath,
    nosort: true,
    mark: true
  });

  _logger.default.debug(`Successfully scanned the tree structure of '${srcRootPath}'`);

  const [foldersToPush, filesToPush] = itemsToPush.reduce((acc, x) => {
    acc[_lodash.default.endsWith(x, _path.default.sep) ? 0 : 1].push(x);
    return acc;
  }, [[], []]);

  _logger.default.debug(`Got ${_support.util.pluralize('folder', foldersToPush.length, true)} and ` + `${_support.util.pluralize('file', filesToPush.length, true)} to push`);

  try {
    await afcService.deleteDirectory(dstRootPath);
  } catch (ign) {}

  await afcService.createDirectory(dstRootPath);
  const foldersToPushByHierarchy = foldersToPush.sort((a, b) => a.split(_path.default.sep).length - b.split(_path.default.sep).length);

  for (const relativeFolderPath of foldersToPushByHierarchy) {
    const absoluteFolderPath = _lodash.default.trimEnd(_path.default.join(dstRootPath, relativeFolderPath), _path.default.sep);

    if (absoluteFolderPath) {
      await afcService.createDirectory(absoluteFolderPath);
    }
  }

  _logger.default.debug(`Successfully created the remote folder structure ` + `(${_support.util.pluralize('item', foldersToPush.length + 1, true)})`);

  const pushFile = async relativePath => {
    const absoluteSourcePath = _path.default.join(srcRootPath, relativePath);

    const readStream = _support.fs.createReadStream(absoluteSourcePath, {
      autoClose: true
    });

    const absoluteDestinationPath = _path.default.join(dstRootPath, relativePath);

    const writeStream = await afcService.createWriteStream(absoluteDestinationPath, {
      autoDestroy: true
    });
    writeStream.on('finish', writeStream.destroy);
    let pushError = null;
    const filePushPromise = new _bluebird.default((resolve, reject) => {
      writeStream.on('close', () => {
        if (pushError) {
          reject(pushError);
        } else {
          resolve();
        }
      });

      const onStreamError = e => {
        readStream.unpipe(writeStream);

        _logger.default.debug(e);

        pushError = e;
      };

      writeStream.on('error', onStreamError);
      readStream.on('error', onStreamError);
    });
    readStream.pipe(writeStream);
    await filePushPromise.timeout(timeoutMs);
  };

  if (enableParallelPush) {
    _logger.default.debug(`Proceeding to parallel files push (max ${MAX_IO_CHUNK_SIZE} writers)`);

    const pushPromises = [];

    for (const relativeFilePath of _lodash.default.shuffle(filesToPush)) {
      pushPromises.push(_bluebird.default.resolve(pushFile(relativeFilePath)));

      if (pushPromises.length >= MAX_IO_CHUNK_SIZE) {
        await _bluebird.default.any(pushPromises);
      }

      _lodash.default.remove(pushPromises, p => p.isFulfilled());
    }

    if (!_lodash.default.isEmpty(pushPromises)) {
      await _bluebird.default.all(pushPromises);
    }
  } else {
    _logger.default.debug(`Proceeding to serial files push`);

    for (const relativeFilePath of filesToPush) {
      await pushFile(relativeFilePath);
    }
  }

  _logger.default.debug(`Successfully pushed ${_support.util.pluralize('folder', foldersToPush.length, true)} ` + `and ${_support.util.pluralize('file', filesToPush.length, true)} ` + `within ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJJT19USU1FT1VUX01TIiwiTUFYX0lPX0NIVU5LX1NJWkUiLCJwdWxsRmlsZSIsImFmY1NlcnZpY2UiLCJyZW1vdGVQYXRoIiwic3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsImF1dG9EZXN0cm95IiwicHVsbFByb21pc2UiLCJCIiwicmVzb2x2ZSIsInJlamVjdCIsIm9uIiwidGltZW91dCIsImJ1ZmZlcnMiLCJkYXRhIiwicHVzaCIsIkJ1ZmZlciIsImNvbmNhdCIsImZvbGRlckV4aXN0cyIsImZvbGRlclBhdGgiLCJmcyIsInN0YXQiLCJpc0RpcmVjdG9yeSIsImUiLCJwdWxsRm9sZGVyIiwicmVtb3RlUm9vdFBhdGgiLCJ0bXBGb2xkZXIiLCJ0ZW1wRGlyIiwib3BlbkRpciIsImxvY2FsVG9wSXRlbSIsImNvdW50RmlsZXNTdWNjZXNzIiwiY291bnRGaWxlc0ZhaWwiLCJjb3VudEZvbGRlcnMiLCJwdWxsUHJvbWlzZXMiLCJ3YWxrRGlyIiwiaXNEaXIiLCJsb2NhbFBhdGgiLCJwYXRoIiwiam9pbiIsImRpcm5hbWUiLCJta2RpcnAiLCJzcGxpdCIsInNlcCIsImxlbmd0aCIsInJlYWRTdHJlYW0iLCJ3cml0ZVN0cmVhbSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiYXV0b0Nsb3NlIiwib25TdHJlYW1pbmdFcnJvciIsInVucGlwZSIsImxvZyIsIndhcm4iLCJtZXNzYWdlIiwicGlwZSIsImFueSIsIl8iLCJyZW1vdmUiLCJwIiwiaXNGdWxmaWxsZWQiLCJpc0VtcHR5IiwiYWxsIiwiaW5mbyIsInV0aWwiLCJwbHVyYWxpemUiLCJ6aXAiLCJ0b0luTWVtb3J5WmlwIiwiZW5jb2RlVG9CYXNlNjQiLCJyaW1yYWYiLCJyZW1vdGVNa2RpcnAiLCJyZW1vdGVSb290IiwibGlzdERpcmVjdG9yeSIsImNyZWF0ZURpcmVjdG9yeSIsInB1c2hGaWxlIiwiYmFzZTY0RGF0YSIsInB1c2hFcnJvciIsInB1c2hQcm9taXNlIiwid3JpdGUiLCJmcm9tIiwiZW5kIiwicHVzaEZvbGRlciIsInNyY1Jvb3RQYXRoIiwiZHN0Um9vdFBhdGgiLCJvcHRzIiwidGltZW91dE1zIiwiZW5hYmxlUGFyYWxsZWxQdXNoIiwidGltZXIiLCJ0aW1pbmciLCJUaW1lciIsInN0YXJ0IiwiaXRlbXNUb1B1c2giLCJnbG9iIiwiY3dkIiwibm9zb3J0IiwibWFyayIsImRlYnVnIiwiZm9sZGVyc1RvUHVzaCIsImZpbGVzVG9QdXNoIiwicmVkdWNlIiwiYWNjIiwieCIsImVuZHNXaXRoIiwiZGVsZXRlRGlyZWN0b3J5IiwiaWduIiwiZm9sZGVyc1RvUHVzaEJ5SGllcmFyY2h5Iiwic29ydCIsImEiLCJiIiwicmVsYXRpdmVGb2xkZXJQYXRoIiwiYWJzb2x1dGVGb2xkZXJQYXRoIiwidHJpbUVuZCIsInJlbGF0aXZlUGF0aCIsImFic29sdXRlU291cmNlUGF0aCIsImFic29sdXRlRGVzdGluYXRpb25QYXRoIiwiZGVzdHJveSIsImZpbGVQdXNoUHJvbWlzZSIsIm9uU3RyZWFtRXJyb3IiLCJwdXNoUHJvbWlzZXMiLCJyZWxhdGl2ZUZpbGVQYXRoIiwic2h1ZmZsZSIsImdldER1cmF0aW9uIiwiYXNNaWxsaVNlY29uZHMiLCJ0b0ZpeGVkIl0sInNvdXJjZXMiOlsiLi4vLi4vbGliL2lvcy1mcy1oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBmcywgdGVtcERpciwgbWtkaXJwLCB6aXAsIHV0aWwsIHRpbWluZyB9IGZyb20gJ2FwcGl1bS9zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5cbmNvbnN0IElPX1RJTUVPVVRfTVMgPSA0ICogNjAgKiAxMDAwO1xuLy8gTW9iaWxlIGRldmljZXMgdXNlIE5BTkQgbWVtb3J5IG1vZHVsZXMgZm9yIHRoZSBzdG9yYWdlLFxuLy8gYW5kIHRoZSBwYXJhbGxlbGlzbSB0aGVyZSBpcyBub3QgYXMgcGVyZm9ybWFudCBhcyBvbiByZWd1bGFyIFNTRHNcbmNvbnN0IE1BWF9JT19DSFVOS19TSVpFID0gODtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGZpbGUgZnJvbSBhIHJlYWwgZGV2aWNlXG4gKlxuICogQHBhcmFtIHtBZmNTZXJ2aWNlfSBhZmNTZXJ2aWNlIEFwcGxlIEZpbGUgQ2xpZW50IHNlcnZpY2UgaW5zdGFuY2UgZnJvbVxuICogJ2FwcGl1bS1pb3MtZGV2aWNlJyBtb2R1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIFJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUgb24gdGhlIGRldmljZVxuICogQHJldHVybnMge0J1ZmZlcn0gVGhlIGZpbGUgY29udGVudCBhcyBhIGJ1ZmZlclxuICovXG5hc3luYyBmdW5jdGlvbiBwdWxsRmlsZSAoYWZjU2VydmljZSwgcmVtb3RlUGF0aCkge1xuICBjb25zdCBzdHJlYW0gPSBhd2FpdCBhZmNTZXJ2aWNlLmNyZWF0ZVJlYWRTdHJlYW0ocmVtb3RlUGF0aCwgeyBhdXRvRGVzdHJveTogdHJ1ZSB9KTtcbiAgY29uc3QgcHVsbFByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpO1xuICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpO1xuICB9KS50aW1lb3V0KElPX1RJTUVPVVRfTVMpO1xuICBjb25zdCBidWZmZXJzID0gW107XG4gIHN0cmVhbS5vbignZGF0YScsIChkYXRhKSA9PiBidWZmZXJzLnB1c2goZGF0YSkpO1xuICBhd2FpdCBwdWxsUHJvbWlzZTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgcHJlc2VuY2Ugb2YgYSBsb2NhbCBmb2xkZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlclBhdGggRnVsbCBwYXRoIHRvIHRoZSBsb2NhbCBmb2xkZXJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBmb2xkZXIgZXhpc3RzIGFuZCBpcyBhY3R1YWxseSBhIGZvbGRlclxuICovXG5hc3luYyBmdW5jdGlvbiBmb2xkZXJFeGlzdHMgKGZvbGRlclBhdGgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGF3YWl0IGZzLnN0YXQoZm9sZGVyUGF0aCkpLmlzRGlyZWN0b3J5KCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGZvbGRlciBmcm9tIGEgcmVhbCBkZXZpY2VcbiAqXG4gKiBAcGFyYW0ge0FmY1NlcnZpY2V9IGFmY1NlcnZpY2UgQXBwbGUgRmlsZSBDbGllbnQgc2VydmljZSBpbnN0YW5jZSBmcm9tXG4gKiAnYXBwaXVtLWlvcy1kZXZpY2UnIG1vZHVsZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVJvb3RQYXRoIFJlbGF0aXZlIHBhdGggdG8gdGhlIGZvbGRlciBvbiB0aGUgZGV2aWNlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBUaGUgZm9sZGVyIGNvbnRlbnQgYXMgYSB6aXBwZWQgYmFzZTY0LWVuY29kZWQgYnVmZmVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGb2xkZXIgKGFmY1NlcnZpY2UsIHJlbW90ZVJvb3RQYXRoKSB7XG4gIGNvbnN0IHRtcEZvbGRlciA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICB0cnkge1xuICAgIGxldCBsb2NhbFRvcEl0ZW0gPSBudWxsO1xuICAgIGxldCBjb3VudEZpbGVzU3VjY2VzcyA9IDA7XG4gICAgbGV0IGNvdW50RmlsZXNGYWlsID0gMDtcbiAgICBsZXQgY291bnRGb2xkZXJzID0gMDtcbiAgICBjb25zdCBwdWxsUHJvbWlzZXMgPSBbXTtcbiAgICBhd2FpdCBhZmNTZXJ2aWNlLndhbGtEaXIocmVtb3RlUm9vdFBhdGgsIHRydWUsIGFzeW5jIChyZW1vdGVQYXRoLCBpc0RpcikgPT4ge1xuICAgICAgY29uc3QgbG9jYWxQYXRoID0gcGF0aC5qb2luKHRtcEZvbGRlciwgcmVtb3RlUGF0aCk7XG4gICAgICBjb25zdCBkaXJuYW1lID0gaXNEaXIgPyBsb2NhbFBhdGggOiBwYXRoLmRpcm5hbWUobG9jYWxQYXRoKTtcbiAgICAgIGlmICghYXdhaXQgZm9sZGVyRXhpc3RzKGRpcm5hbWUpKSB7XG4gICAgICAgIGF3YWl0IG1rZGlycChkaXJuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghbG9jYWxUb3BJdGVtXG4gICAgICAgICAgfHwgbG9jYWxQYXRoLnNwbGl0KHBhdGguc2VwKS5sZW5ndGggPCBsb2NhbFRvcEl0ZW0uc3BsaXQocGF0aC5zZXApLmxlbmd0aCkge1xuICAgICAgICBsb2NhbFRvcEl0ZW0gPSBsb2NhbFBhdGg7XG4gICAgICB9XG4gICAgICBpZiAoaXNEaXIpIHtcbiAgICAgICAgKytjb3VudEZvbGRlcnM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhZFN0cmVhbSA9IGF3YWl0IGFmY1NlcnZpY2UuY3JlYXRlUmVhZFN0cmVhbShyZW1vdGVQYXRoLCB7YXV0b0Rlc3Ryb3k6IHRydWV9KTtcbiAgICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0obG9jYWxQYXRoLCB7YXV0b0Nsb3NlOiB0cnVlfSk7XG4gICAgICBwdWxsUHJvbWlzZXMucHVzaChcbiAgICAgICAgbmV3IEIoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICB3cml0ZVN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICArK2NvdW50RmlsZXNTdWNjZXNzO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IG9uU3RyZWFtaW5nRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgcmVhZFN0cmVhbS51bnBpcGUod3JpdGVTdHJlYW0pO1xuICAgICAgICAgICAgbG9nLndhcm4oYENhbm5vdCBwdWxsICcke3JlbW90ZVBhdGh9JyB0byAnJHtsb2NhbFBhdGh9Jy4gYCArXG4gICAgICAgICAgICAgIGBUaGUgZmlsZSB3aWxsIGJlIHNraXBwZWQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICsrY291bnRGaWxlc0ZhaWw7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3cml0ZVN0cmVhbS5vbignZXJyb3InLCBvblN0cmVhbWluZ0Vycm9yKTtcbiAgICAgICAgICByZWFkU3RyZWFtLm9uKCdlcnJvcicsIG9uU3RyZWFtaW5nRXJyb3IpO1xuICAgICAgICB9KS50aW1lb3V0KElPX1RJTUVPVVRfTVMpXG4gICAgICApO1xuICAgICAgcmVhZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcbiAgICAgIGlmIChwdWxsUHJvbWlzZXMubGVuZ3RoID49IE1BWF9JT19DSFVOS19TSVpFKSB7XG4gICAgICAgIGF3YWl0IEIuYW55KHB1bGxQcm9taXNlcyk7XG4gICAgICB9XG4gICAgICBfLnJlbW92ZShwdWxsUHJvbWlzZXMsIChwKSA9PiBwLmlzRnVsZmlsbGVkKCkpO1xuICAgIH0pO1xuICAgIC8vIFdhaXQgZm9yIHRoZSByZXN0IG9mIGZpbGVzIHRvIGJlIHB1bGxlZFxuICAgIGlmICghXy5pc0VtcHR5KHB1bGxQcm9taXNlcykpIHtcbiAgICAgIGF3YWl0IEIuYWxsKHB1bGxQcm9taXNlcyk7XG4gICAgfVxuICAgIGxvZy5pbmZvKGBQdWxsZWQgJHt1dGlsLnBsdXJhbGl6ZSgnZmlsZScsIGNvdW50RmlsZXNTdWNjZXNzLCB0cnVlKX0gb3V0IG9mIGAgK1xuICAgICAgYCR7Y291bnRGaWxlc1N1Y2Nlc3MgKyBjb3VudEZpbGVzRmFpbH0gYW5kICR7dXRpbC5wbHVyYWxpemUoJ2ZvbGRlcicsIGNvdW50Rm9sZGVycywgdHJ1ZSl9IGAgK1xuICAgICAgYGZyb20gJyR7cmVtb3RlUm9vdFBhdGh9J2ApO1xuICAgIHJldHVybiBhd2FpdCB6aXAudG9Jbk1lbW9yeVppcChsb2NhbFRvcEl0ZW0gPyBwYXRoLmRpcm5hbWUobG9jYWxUb3BJdGVtKSA6IHRtcEZvbGRlciwge1xuICAgICAgZW5jb2RlVG9CYXNlNjQ6IHRydWUsXG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcEZvbGRlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIHJlbW90ZSBmb2xkZXIgcGF0aCByZWN1cnNpdmVseS4gTm9vcCBpZiB0aGUgZ2l2ZW4gcGF0aFxuICogYWxyZWFkeSBleGlzdHNcbiAqXG4gKiBAcGFyYW0ge0FmY1NlcnZpY2V9IGFmY1NlcnZpY2UgQXBwbGUgRmlsZSBDbGllbnQgc2VydmljZSBpbnN0YW5jZSBmcm9tXG4gKiAnYXBwaXVtLWlvcy1kZXZpY2UnIG1vZHVsZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVJvb3QgVGhlIHJlbGF0aXZlIHBhdGggdG8gdGhlIHJlbW90ZSBmb2xkZXIgc3RydWN0dXJlXG4gKiB0byBiZSBjcmVhdGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZU1rZGlycCAoYWZjU2VydmljZSwgcmVtb3RlUm9vdCkge1xuICBpZiAocmVtb3RlUm9vdCA9PT0gJy4nIHx8IHJlbW90ZVJvb3QgPT09ICcvJykge1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IGFmY1NlcnZpY2UubGlzdERpcmVjdG9yeShyZW1vdGVSb290KTtcbiAgICByZXR1cm47XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIGRpcmVjdG9yeSBpcyBtaXNzaW5nIGFuZCB3ZSBnb3QgYW4gb2JqZWN0IG5vdCBmb3VuZCBlcnJvci5cbiAgICAvLyBUaGVyZWZvcmUsIHdlIGFyZSBnb2luZyB0byB0aGUgcGFyZW50XG4gICAgYXdhaXQgcmVtb3RlTWtkaXJwKGFmY1NlcnZpY2UsIHBhdGguZGlybmFtZShyZW1vdGVSb290KSk7XG4gIH1cbiAgYXdhaXQgYWZjU2VydmljZS5jcmVhdGVEaXJlY3RvcnkocmVtb3RlUm9vdCk7XG59XG5cbi8qKlxuICogUHVzaGVzIGEgZmlsZSB0byBhIHJlYWwgZGV2aWNlXG4gKlxuICogQHBhcmFtIHtBZmNTZXJ2aWNlfSBhZmNTZXJ2aWNlIEFwcGxlIEZpbGUgQ2xpZW50IHNlcnZpY2UgaW5zdGFuY2UgZnJvbVxuICogJ2FwcGl1bS1pb3MtZGV2aWNlJyBtb2R1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIFJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUgb24gdGhlIGRldmljZS4gVGhlIHJlbW90ZVxuICogZm9sZGVyIHN0cnVjdHVyZSBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NERhdGEgQmFzZTY0LWVuY29kZWQgY29udGVudCBvZiB0aGUgZmlsZSB0byBiZSB3cml0dGVuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlIChhZmNTZXJ2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGF3YWl0IHJlbW90ZU1rZGlycChhZmNTZXJ2aWNlLCBwYXRoLmRpcm5hbWUocmVtb3RlUGF0aCkpO1xuICBjb25zdCBzdHJlYW0gPSBhd2FpdCBhZmNTZXJ2aWNlLmNyZWF0ZVdyaXRlU3RyZWFtKHJlbW90ZVBhdGgsIHthdXRvRGVzdHJveTogdHJ1ZX0pO1xuICBsZXQgcHVzaEVycm9yID0gbnVsbDtcbiAgY29uc3QgcHVzaFByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICBwdXNoRXJyb3IgPSBlO1xuICAgIH0pO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICBpZiAocHVzaEVycm9yKSB7XG4gICAgICAgIHJlamVjdChwdXNoRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KS50aW1lb3V0KElPX1RJTUVPVVRfTVMpO1xuICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oYmFzZTY0RGF0YSwgJ2Jhc2U2NCcpKTtcbiAgc3RyZWFtLmVuZCgpO1xuICBhd2FpdCBwdXNoUHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQdXNoRm9sZGVyT3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lb3V0TXMgWzI0MDAwMF0gVGhlIG1heGltdW0gdGltZW91dCB0byB3YWl0IHVudGlsIGFcbiAqIHNpbmdsZSBmaWxlIGlzIGNvcGllZFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVQYXJhbGxlbFB1c2ggW2ZhbHNlXSBXaGV0aGVyIHRvIHB1c2ggZmlsZXMgaW4gcGFyYWxsZWwuXG4gKiBUaGlzIHVzdWFsbHkgZ2l2ZXMgYmV0dGVyIHBlcmZvcm1hbmNlLCBidXQgbWlnaHQgc29tZXRpbWVzIGJlIGxlc3Mgc3RhYmxlLlxuICovXG5cbi8qKlxuICogUHVzaGVzIGEgZm9sZGVyIHRvIGEgcmVhbCBkZXZpY2VcbiAqXG4gKiBAcGFyYW0ge0FmY1NlcnZpY2V9IGFmY1NlcnZpY2UgQXBwbGUgRmlsZSBDbGllbnQgc2VydmljZSBpbnN0YW5jZSBmcm9tXG4gKiAnYXBwaXVtLWlvcy1kZXZpY2UnIG1vZHVsZVxuICogQHBhcmFtIHtzdHJpbmd9IHNyY1Jvb3RQYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIHNvdXJjZSBmb2xkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkc3RSb290UGF0aCBUaGUgcmVsYXRpdmUgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyLiBUaGUgZm9sZGVyXG4gKiB3aWxsIGJlIGRlbGV0ZWQgaWYgYWxyZWFkeSBleGlzdHMuXG4gKiBAcGFyYW0ge1B1c2hGb2xkZXJPcHRpb25zfSBvcHRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1c2hGb2xkZXIgKGFmY1NlcnZpY2UsIHNyY1Jvb3RQYXRoLCBkc3RSb290UGF0aCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0aW1lb3V0TXMgPSBJT19USU1FT1VUX01TLFxuICAgIGVuYWJsZVBhcmFsbGVsUHVzaCA9IGZhbHNlLFxuICB9ID0gb3B0cztcblxuICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICBjb25zdCBpdGVtc1RvUHVzaCA9IGF3YWl0IGZzLmdsb2IoJyoqJywge1xuICAgIGN3ZDogc3JjUm9vdFBhdGgsXG4gICAgbm9zb3J0OiB0cnVlLFxuICAgIG1hcms6IHRydWUsXG4gIH0pO1xuICBsb2cuZGVidWcoYFN1Y2Nlc3NmdWxseSBzY2FubmVkIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiAnJHtzcmNSb290UGF0aH0nYCk7XG4gIGNvbnN0IFtmb2xkZXJzVG9QdXNoLCBmaWxlc1RvUHVzaF0gPSBpdGVtc1RvUHVzaC5yZWR1Y2UoKGFjYywgeCkgPT4ge1xuICAgIGFjY1tfLmVuZHNXaXRoKHgsIHBhdGguc2VwKSA/IDAgOiAxXS5wdXNoKHgpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtbXSwgW11dKTtcbiAgbG9nLmRlYnVnKGBHb3QgJHt1dGlsLnBsdXJhbGl6ZSgnZm9sZGVyJywgZm9sZGVyc1RvUHVzaC5sZW5ndGgsIHRydWUpfSBhbmQgYCArXG4gICAgYCR7dXRpbC5wbHVyYWxpemUoJ2ZpbGUnLCBmaWxlc1RvUHVzaC5sZW5ndGgsIHRydWUpfSB0byBwdXNoYCk7XG4gIC8vIGNyZWF0ZSB0aGUgZm9sZGVyIHN0cnVjdHVyZSBmaXJzdFxuICB0cnkge1xuICAgIGF3YWl0IGFmY1NlcnZpY2UuZGVsZXRlRGlyZWN0b3J5KGRzdFJvb3RQYXRoKTtcbiAgfSBjYXRjaCAoaWduKSB7fVxuICBhd2FpdCBhZmNTZXJ2aWNlLmNyZWF0ZURpcmVjdG9yeShkc3RSb290UGF0aCk7XG4gIC8vIHRvcC1sZXZlbCBmb2xkZXJzIG11c3QgZ28gZmlyc3RcbiAgY29uc3QgZm9sZGVyc1RvUHVzaEJ5SGllcmFyY2h5ID0gZm9sZGVyc1RvUHVzaFxuICAgIC5zb3J0KChhLCBiKSA9PiBhLnNwbGl0KHBhdGguc2VwKS5sZW5ndGggLSBiLnNwbGl0KHBhdGguc2VwKS5sZW5ndGgpO1xuICBmb3IgKGNvbnN0IHJlbGF0aXZlRm9sZGVyUGF0aCBvZiBmb2xkZXJzVG9QdXNoQnlIaWVyYXJjaHkpIHtcbiAgICAvLyBjcmVhdGVEaXJlY3RvcnkgZG9lcyBub3QgYWNjZXB0IGZvbGRlciBuYW1lcyBlbmRpbmcgd2l0aCBhIHBhdGggc2VwYXJhdG9yXG4gICAgY29uc3QgYWJzb2x1dGVGb2xkZXJQYXRoID0gXy50cmltRW5kKFxuICAgICAgcGF0aC5qb2luKGRzdFJvb3RQYXRoLCByZWxhdGl2ZUZvbGRlclBhdGgpLCBwYXRoLnNlcFxuICAgICk7XG4gICAgaWYgKGFic29sdXRlRm9sZGVyUGF0aCkge1xuICAgICAgYXdhaXQgYWZjU2VydmljZS5jcmVhdGVEaXJlY3RvcnkoYWJzb2x1dGVGb2xkZXJQYXRoKTtcbiAgICB9XG4gIH1cbiAgLy8gZG8gbm90IGZvcmdldCBhYm91dCB0aGUgcm9vdCBmb2xkZXJcbiAgbG9nLmRlYnVnKGBTdWNjZXNzZnVsbHkgY3JlYXRlZCB0aGUgcmVtb3RlIGZvbGRlciBzdHJ1Y3R1cmUgYCArXG4gICAgYCgke3V0aWwucGx1cmFsaXplKCdpdGVtJywgZm9sZGVyc1RvUHVzaC5sZW5ndGggKyAxLCB0cnVlKX0pYCk7XG5cbiAgY29uc3QgcHVzaEZpbGUgPSBhc3luYyAocmVsYXRpdmVQYXRoKSA9PiB7XG4gICAgY29uc3QgYWJzb2x1dGVTb3VyY2VQYXRoID0gcGF0aC5qb2luKHNyY1Jvb3RQYXRoLCByZWxhdGl2ZVBhdGgpO1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGFic29sdXRlU291cmNlUGF0aCwge2F1dG9DbG9zZTogdHJ1ZX0pO1xuICAgIGNvbnN0IGFic29sdXRlRGVzdGluYXRpb25QYXRoID0gcGF0aC5qb2luKGRzdFJvb3RQYXRoLCByZWxhdGl2ZVBhdGgpO1xuICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gYXdhaXQgYWZjU2VydmljZS5jcmVhdGVXcml0ZVN0cmVhbShhYnNvbHV0ZURlc3RpbmF0aW9uUGF0aCwge1xuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWVcbiAgICB9KTtcbiAgICB3cml0ZVN0cmVhbS5vbignZmluaXNoJywgd3JpdGVTdHJlYW0uZGVzdHJveSk7XG4gICAgbGV0IHB1c2hFcnJvciA9IG51bGw7XG4gICAgY29uc3QgZmlsZVB1c2hQcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgd3JpdGVTdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBpZiAocHVzaEVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHB1c2hFcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9uU3RyZWFtRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICByZWFkU3RyZWFtLnVucGlwZSh3cml0ZVN0cmVhbSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhlKTtcbiAgICAgICAgcHVzaEVycm9yID0gZTtcbiAgICAgIH07XG4gICAgICB3cml0ZVN0cmVhbS5vbignZXJyb3InLCBvblN0cmVhbUVycm9yKTtcbiAgICAgIHJlYWRTdHJlYW0ub24oJ2Vycm9yJywgb25TdHJlYW1FcnJvcik7XG4gICAgfSk7XG4gICAgcmVhZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcbiAgICBhd2FpdCBmaWxlUHVzaFByb21pc2UudGltZW91dCh0aW1lb3V0TXMpO1xuICB9O1xuXG4gIGlmIChlbmFibGVQYXJhbGxlbFB1c2gpIHtcbiAgICBsb2cuZGVidWcoYFByb2NlZWRpbmcgdG8gcGFyYWxsZWwgZmlsZXMgcHVzaCAobWF4ICR7TUFYX0lPX0NIVU5LX1NJWkV9IHdyaXRlcnMpYCk7XG4gICAgY29uc3QgcHVzaFByb21pc2VzID0gW107XG4gICAgZm9yIChjb25zdCByZWxhdGl2ZUZpbGVQYXRoIG9mIF8uc2h1ZmZsZShmaWxlc1RvUHVzaCkpIHtcbiAgICAgIHB1c2hQcm9taXNlcy5wdXNoKEIucmVzb2x2ZShwdXNoRmlsZShyZWxhdGl2ZUZpbGVQYXRoKSkpO1xuICAgICAgLy8ga2VlcCB0aGUgcHVzaCBxdWV1ZSBmaWxsZWRcbiAgICAgIGlmIChwdXNoUHJvbWlzZXMubGVuZ3RoID49IE1BWF9JT19DSFVOS19TSVpFKSB7XG4gICAgICAgIGF3YWl0IEIuYW55KHB1c2hQcm9taXNlcyk7XG4gICAgICB9XG4gICAgICBfLnJlbW92ZShwdXNoUHJvbWlzZXMsIChwKSA9PiBwLmlzRnVsZmlsbGVkKCkpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNFbXB0eShwdXNoUHJvbWlzZXMpKSB7XG4gICAgICAvLyBoYW5kbGUgdGhlIHJlc3Qgb2YgcHVzaCBwcm9taXNlc1xuICAgICAgYXdhaXQgQi5hbGwocHVzaFByb21pc2VzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbG9nLmRlYnVnKGBQcm9jZWVkaW5nIHRvIHNlcmlhbCBmaWxlcyBwdXNoYCk7XG4gICAgZm9yIChjb25zdCByZWxhdGl2ZUZpbGVQYXRoIG9mIGZpbGVzVG9QdXNoKSB7XG4gICAgICBhd2FpdCBwdXNoRmlsZShyZWxhdGl2ZUZpbGVQYXRoKTtcbiAgICB9XG4gIH1cblxuICBsb2cuZGVidWcoYFN1Y2Nlc3NmdWxseSBwdXNoZWQgJHt1dGlsLnBsdXJhbGl6ZSgnZm9sZGVyJywgZm9sZGVyc1RvUHVzaC5sZW5ndGgsIHRydWUpfSBgICtcbiAgICBgYW5kICR7dXRpbC5wbHVyYWxpemUoJ2ZpbGUnLCBmaWxlc1RvUHVzaC5sZW5ndGgsIHRydWUpfSBgICtcbiAgICBgd2l0aGluICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc01pbGxpU2Vjb25kcy50b0ZpeGVkKDApfW1zYCk7XG59XG5cblxuZXhwb3J0IHsgcHVsbEZpbGUsIHB1bGxGb2xkZXIsIHB1c2hGaWxlLCBwdXNoRm9sZGVyIH07Il0s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