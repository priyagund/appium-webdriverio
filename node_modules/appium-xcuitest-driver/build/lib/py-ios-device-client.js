"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Pyidevice = void 0;

require("source-map-support/register");

var _teen_process = require("teen_process");

var _support = require("appium/support");

var _logger = _interopRequireDefault(require("./logger"));

var _path = _interopRequireDefault(require("path"));

const BINARY_NAME = 'pyidevice';

class Pyidevice {
  constructor(udid) {
    this.udid = udid;
    this.binaryPath = null;
  }

  async assertExists(isStrict = true) {
    if (this.binaryPath) {
      return true;
    }

    try {
      this.binaryPath = await _support.fs.which(BINARY_NAME);
      return true;
    } catch (e) {
      if (isStrict) {
        throw new Error(`${BINARY_NAME} binary cannot be found in PATH. ` + `Please make sure it is installed. Visit https://github.com/YueChen-C/py-ios-device for ` + `more details.`);
      }

      return false;
    }
  }

  async execute(args, opts = {}) {
    await this.assertExists();
    const {
      cwd,
      format = 'json',
      logStdout = false,
      asynchronous = false
    } = opts;
    const finalArgs = [...args, '--udid', this.udid];

    if (format) {
      finalArgs.push('--format', format);
    }

    const cmdStr = _support.util.quote([this.binaryPath, ...finalArgs]);

    _logger.default.debug(`Executing ${cmdStr}`);

    try {
      if (asynchronous) {
        const result = new _teen_process.SubProcess(this.binaryPath, finalArgs, {
          cwd
        });
        await result.start(0);
        return result;
      }

      const result = await (0, _teen_process.exec)(this.binaryPath, finalArgs, {
        cwd
      });

      if (logStdout) {
        _logger.default.debug(`Command output: ${result.stdout}`);
      }

      return result;
    } catch (e) {
      throw new Error(`'${cmdStr}' failed. Original error: ${e.stderr || e.stdout || e.message}`);
    }
  }

  async listProfiles() {
    const {
      stdout
    } = await this.execute(['profiles', 'list']);
    return JSON.parse(stdout);
  }

  async installProfile({
    profilePath,
    payload
  } = {}) {
    if (!profilePath && !payload) {
      throw new Error('Either the full path to the profile or its payload must be provided');
    }

    let tmpRoot;
    let srcPath = profilePath;

    try {
      if (!srcPath) {
        tmpRoot = await _support.tempDir.openDir();
        srcPath = _path.default.join(tmpRoot, 'cert.pem');
        await _support.fs.writeFile(srcPath, payload, 'utf8');
      }

      await this.execute(['profiles', 'install', '--path', srcPath], {
        logStdout: true
      });
    } finally {
      if (tmpRoot) {
        await _support.fs.rimraf(tmpRoot);
      }
    }
  }

  async removeProfile(name) {
    await this.execute(['profiles', 'remove', name], {
      logStdout: true
    });
  }

  async listCrashes() {
    const {
      stdout
    } = await this.execute(['crash', 'list']);
    return JSON.parse(stdout.replace(/'/g, '"')).filter(x => !['.', '..'].includes(x));
  }

  async exportCrash(name, dstFolder) {
    await this.execute(['crash', 'export', '--name', name], {
      logStdout: true,
      cwd: dstFolder
    });
  }

  async collectPcap(dstFile) {
    return await this.execute(['pcapd', dstFile], {
      format: null,
      asynchronous: true
    });
  }

}

exports.Pyidevice = Pyidevice;
var _default = Pyidevice;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCSU5BUllfTkFNRSIsIlB5aWRldmljZSIsImNvbnN0cnVjdG9yIiwidWRpZCIsImJpbmFyeVBhdGgiLCJhc3NlcnRFeGlzdHMiLCJpc1N0cmljdCIsImZzIiwid2hpY2giLCJlIiwiRXJyb3IiLCJleGVjdXRlIiwiYXJncyIsIm9wdHMiLCJjd2QiLCJmb3JtYXQiLCJsb2dTdGRvdXQiLCJhc3luY2hyb25vdXMiLCJmaW5hbEFyZ3MiLCJwdXNoIiwiY21kU3RyIiwidXRpbCIsInF1b3RlIiwibG9nIiwiZGVidWciLCJyZXN1bHQiLCJTdWJQcm9jZXNzIiwic3RhcnQiLCJleGVjIiwic3Rkb3V0Iiwic3RkZXJyIiwibWVzc2FnZSIsImxpc3RQcm9maWxlcyIsIkpTT04iLCJwYXJzZSIsImluc3RhbGxQcm9maWxlIiwicHJvZmlsZVBhdGgiLCJwYXlsb2FkIiwidG1wUm9vdCIsInNyY1BhdGgiLCJ0ZW1wRGlyIiwib3BlbkRpciIsInBhdGgiLCJqb2luIiwid3JpdGVGaWxlIiwicmltcmFmIiwicmVtb3ZlUHJvZmlsZSIsIm5hbWUiLCJsaXN0Q3Jhc2hlcyIsInJlcGxhY2UiLCJmaWx0ZXIiLCJ4IiwiaW5jbHVkZXMiLCJleHBvcnRDcmFzaCIsImRzdEZvbGRlciIsImNvbGxlY3RQY2FwIiwiZHN0RmlsZSJdLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9weS1pb3MtZGV2aWNlLWNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjLCBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IGZzLCB1dGlsLCB0ZW1wRGlyIH0gZnJvbSAnYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1l1ZUNoZW4tQy9weS1pb3MtZGV2aWNlXG5cbmNvbnN0IEJJTkFSWV9OQU1FID0gJ3B5aWRldmljZSc7XG5cbmNsYXNzIFB5aWRldmljZSB7XG4gIGNvbnN0cnVjdG9yICh1ZGlkKSB7XG4gICAgdGhpcy51ZGlkID0gdWRpZDtcbiAgICB0aGlzLmJpbmFyeVBhdGggPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgYXNzZXJ0RXhpc3RzIChpc1N0cmljdCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5iaW5hcnlQYXRoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5iaW5hcnlQYXRoID0gYXdhaXQgZnMud2hpY2goQklOQVJZX05BTUUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtCSU5BUllfTkFNRX0gYmluYXJ5IGNhbm5vdCBiZSBmb3VuZCBpbiBQQVRILiBgICtcbiAgICAgICAgICBgUGxlYXNlIG1ha2Ugc3VyZSBpdCBpcyBpbnN0YWxsZWQuIFZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9ZdWVDaGVuLUMvcHktaW9zLWRldmljZSBmb3IgYCArXG4gICAgICAgICAgYG1vcmUgZGV0YWlscy5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBleGVjdXRlIChhcmdzLCBvcHRzID0ge30pIHtcbiAgICBhd2FpdCB0aGlzLmFzc2VydEV4aXN0cygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN3ZCxcbiAgICAgIGZvcm1hdCA9ICdqc29uJyxcbiAgICAgIGxvZ1N0ZG91dCA9IGZhbHNlLFxuICAgICAgYXN5bmNocm9ub3VzID0gZmFsc2UsXG4gICAgfSA9IG9wdHM7XG5cbiAgICBjb25zdCBmaW5hbEFyZ3MgPSBbLi4uYXJncywgJy0tdWRpZCcsIHRoaXMudWRpZF07XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgZmluYWxBcmdzLnB1c2goJy0tZm9ybWF0JywgZm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgY21kU3RyID0gdXRpbC5xdW90ZShbdGhpcy5iaW5hcnlQYXRoLCAuLi5maW5hbEFyZ3NdKTtcbiAgICBsb2cuZGVidWcoYEV4ZWN1dGluZyAke2NtZFN0cn1gKTtcbiAgICB0cnkge1xuICAgICAgaWYgKGFzeW5jaHJvbm91cykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3ViUHJvY2Vzcyh0aGlzLmJpbmFyeVBhdGgsIGZpbmFsQXJncywge2N3ZH0pO1xuICAgICAgICBhd2FpdCByZXN1bHQuc3RhcnQoMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjKHRoaXMuYmluYXJ5UGF0aCwgZmluYWxBcmdzLCB7Y3dkfSk7XG4gICAgICBpZiAobG9nU3Rkb3V0KSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgQ29tbWFuZCBvdXRwdXQ6ICR7cmVzdWx0LnN0ZG91dH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtjbWRTdHJ9JyBmYWlsZWQuIE9yaWdpbmFsIGVycm9yOiAke2Uuc3RkZXJyIHx8IGUuc3Rkb3V0IHx8IGUubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBsaXN0UHJvZmlsZXMgKCkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgdGhpcy5leGVjdXRlKFsncHJvZmlsZXMnLCAnbGlzdCddKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdGRvdXQpO1xuICB9XG5cbiAgYXN5bmMgaW5zdGFsbFByb2ZpbGUgKHtwcm9maWxlUGF0aCwgcGF5bG9hZH0gPSB7fSkge1xuICAgIGlmICghcHJvZmlsZVBhdGggJiYgIXBheWxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRWl0aGVyIHRoZSBmdWxsIHBhdGggdG8gdGhlIHByb2ZpbGUgb3IgaXRzIHBheWxvYWQgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGxldCB0bXBSb290O1xuICAgIGxldCBzcmNQYXRoID0gcHJvZmlsZVBhdGg7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc3JjUGF0aCkge1xuICAgICAgICB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gICAgICAgIHNyY1BhdGggPSBwYXRoLmpvaW4odG1wUm9vdCwgJ2NlcnQucGVtJyk7XG4gICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShzcmNQYXRoLCBwYXlsb2FkLCAndXRmOCcpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5leGVjdXRlKFsncHJvZmlsZXMnLCAnaW5zdGFsbCcsICctLXBhdGgnLCBzcmNQYXRoXSwge1xuICAgICAgICBsb2dTdGRvdXQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodG1wUm9vdCkge1xuICAgICAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVtb3ZlUHJvZmlsZSAobmFtZSkge1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShbJ3Byb2ZpbGVzJywgJ3JlbW92ZScsIG5hbWVdLCB7bG9nU3Rkb3V0OiB0cnVlfSk7XG4gIH1cblxuICBhc3luYyBsaXN0Q3Jhc2hlcyAoKSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0aGlzLmV4ZWN1dGUoWydjcmFzaCcsICdsaXN0J10pO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0ZG91dC5yZXBsYWNlKC8nL2csICdcIicpKS5maWx0ZXIoKHgpID0+ICFbJy4nLCAnLi4nXS5pbmNsdWRlcyh4KSk7XG4gIH1cblxuICBhc3luYyBleHBvcnRDcmFzaCAobmFtZSwgZHN0Rm9sZGVyKSB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlKFsnY3Jhc2gnLCAnZXhwb3J0JywgJy0tbmFtZScsIG5hbWVdLCB7XG4gICAgICBsb2dTdGRvdXQ6IHRydWUsXG4gICAgICAvLyBUaGUgdG9vbCBleHBvcnRzIGNyYXNoIHJlcG9ydHMgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJcbiAgICAgIGN3ZDogZHN0Rm9sZGVyXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjb2xsZWN0UGNhcCAoZHN0RmlsZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGUoWydwY2FwZCcsIGRzdEZpbGVdLCB7XG4gICAgICBmb3JtYXQ6IG51bGwsXG4gICAgICBhc3luY2hyb25vdXM6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBQeWlkZXZpY2UgfTtcbmV4cG9ydCBkZWZhdWx0IFB5aWRldmljZTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQSxNQUFNQSxXQUFXLEdBQUcsV0FBcEI7O0FBRUEsTUFBTUMsU0FBTixDQUFnQjtFQUNkQyxXQUFXLENBQUVDLElBQUYsRUFBUTtJQUNqQixLQUFLQSxJQUFMLEdBQVlBLElBQVo7SUFDQSxLQUFLQyxVQUFMLEdBQWtCLElBQWxCO0VBQ0Q7O0VBRWlCLE1BQVpDLFlBQVksQ0FBRUMsUUFBUSxHQUFHLElBQWIsRUFBbUI7SUFDbkMsSUFBSSxLQUFLRixVQUFULEVBQXFCO01BQ25CLE9BQU8sSUFBUDtJQUNEOztJQUVELElBQUk7TUFDRixLQUFLQSxVQUFMLEdBQWtCLE1BQU1HLFdBQUEsQ0FBR0MsS0FBSCxDQUFTUixXQUFULENBQXhCO01BQ0EsT0FBTyxJQUFQO0lBQ0QsQ0FIRCxDQUdFLE9BQU9TLENBQVAsRUFBVTtNQUNWLElBQUlILFFBQUosRUFBYztRQUNaLE1BQU0sSUFBSUksS0FBSixDQUFXLEdBQUVWLFdBQVksbUNBQWYsR0FDYix5RkFEYSxHQUViLGVBRkcsQ0FBTjtNQUdEOztNQUNELE9BQU8sS0FBUDtJQUNEO0VBQ0Y7O0VBRVksTUFBUFcsT0FBTyxDQUFFQyxJQUFGLEVBQVFDLElBQUksR0FBRyxFQUFmLEVBQW1CO0lBQzlCLE1BQU0sS0FBS1IsWUFBTCxF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