{"version":3,"file":"file-movement.js","names":["CONTAINER_PATH_MARKER","CONTAINER_PATH_PATTERN","RegExp","CONTAINER_TYPE_SEPARATOR","CONTAINER_DOCUMENTS_PATH","OBJECT_NOT_FOUND_ERROR_MESSAGE","commands","verifyIsSubPath","originalPath","root","normalizedRoot","path","normalize","normalizedPath","dirname","startsWith","Error","createAfcClient","udid","bundleId","containerType","services","startAfcService","service","startHouseArrestService","isDocumentsContainer","vendDocuments","vendContainer","_","toLower","createService","remotePath","test","pathInContainer","parseContainerPath","relativePath","join","containerRootSupplier","match","exec","typeSeparatorPos","indexOf","length","substring","log","debug","isNil","containerRoot","isFunction","posix","resolve","pushFileToSimulator","device","base64Data","buffer","Buffer","from","dstPath","appBundle","simctl","getAppContainer","info","fs","exists","mkdirp","writeFile","dstFolder","tempDir","openDir","basename","addMedia","rimraf","pushFileToRealDevice","pushFile","e","stack","message","close","deleteFileOrFolder","isSimulator","deleteFromSimulator","deleteFromRealDevice","pullFromSimulator","isFile","pathOnServer","simRoot","getDir","errorAndThrow","util","toInMemoryBase64","zip","toInMemoryZip","encodeToBase64","toString","pullFromRealDevice","fileInfo","getFileInfo","isDirectory","pullFile","pullFolder","errors","InvalidArgumentError","deleteDirectory","includes","endsWith","isArray","opts","mobilePushFile","payload","requireArgs","mobilePullFile","mobileDeleteFolder","mobileDeleteFile","mobilePullFolder"],"sources":["../../../lib/commands/file-movement.js"],"sourcesContent":["import _ from 'lodash';\nimport { fs, tempDir, mkdirp, zip, util } from 'appium/support';\nimport path from 'path';\nimport log from '../logger';\nimport { services } from 'appium-ios-device';\nimport { pullFile, pullFolder, pushFile } from '../ios-fs-helpers';\nimport { errors } from 'appium/driver';\nimport { requireArgs } from '../utils';\n\nconst CONTAINER_PATH_MARKER = '@';\n// https://regex101.com/r/PLdB0G/2\nconst CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);\nconst CONTAINER_TYPE_SEPARATOR = ':';\nconst CONTAINER_DOCUMENTS_PATH = 'Documents';\nconst OBJECT_NOT_FOUND_ERROR_MESSAGE = 'OBJECT_NOT_FOUND';\n\nconst commands = {};\n\nfunction verifyIsSubPath (originalPath, root) {\n  const normalizedRoot = path.normalize(root);\n  const normalizedPath = path.normalize(path.dirname(originalPath));\n  // If originalPath is root, `/`, originalPath should equal to normalizedRoot\n  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {\n    throw new Error(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);\n  }\n}\n\nasync function createAfcClient (udid, bundleId, containerType) {\n  if (!bundleId) {\n    return await services.startAfcService(udid);\n  }\n  const service = await services.startHouseArrestService(udid);\n  return isDocumentsContainer(containerType)\n    ? await service.vendDocuments(bundleId)\n    : await service.vendContainer(bundleId);\n}\n\nfunction isDocumentsContainer (containerType) {\n  return _.toLower(containerType) === _.toLower(CONTAINER_DOCUMENTS_PATH);\n}\n\nasync function createService (udid, remotePath) {\n  if (CONTAINER_PATH_PATTERN.test(remotePath)) {\n    const {bundleId, pathInContainer, containerType} = await parseContainerPath(remotePath);\n    const service = await createAfcClient(udid, bundleId, containerType);\n    const relativePath = isDocumentsContainer(containerType)\n      ? path.join(CONTAINER_DOCUMENTS_PATH, pathInContainer)\n      : pathInContainer;\n    return {service, relativePath};\n  } else {\n    const service = await createAfcClient(udid);\n    return {service, relativePath: remotePath};\n  }\n}\n\n/**\n * @typedef {Object} ContainerObject\n *\n * @property {string} bundleId - The parsed bundle identifier\n * @property {string} pathInContainer - The absolute full path of the item on the local file system\n * @property {?string} containerType - The container type\n */\n\n/**\n * Parses the actual path and the bundle identifier from the given path string\n *\n * @param {string} remotePath - The given path string. The string should\n * match `CONTAINER_PATH_PATTERN` regexp, otherwise an error is going\n * to be thrown. A valid string example: `@bundle.identifier:container_type/relative_path_in_container`\n * @param {Function|string} containerRootSupplier - Either a string, that contains\n * full path to the mount root for real devices or a function, which accepts two parameters\n * (bundle identifier and optional container type) and returns full path to container\n * root folder on the local file system, for Simulator\n * @returns {ContainerObject}\n */\nasync function parseContainerPath (remotePath, containerRootSupplier) {\n  const match = CONTAINER_PATH_PATTERN.exec(remotePath);\n  if (!match) {\n    throw new Error(`It is expected that package identifier ` +\n      `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` +\n      `relative path with a single slash. '${remotePath}' is given instead`);\n  }\n  let [, bundleId, relativePath] = match;\n  let containerType = null;\n  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);\n  // We only consider container type exists if its length is greater than zero\n  // not counting the colon\n  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {\n    containerType = bundleId.substring(typeSeparatorPos + 1);\n    log.debug(`Parsed container type: ${containerType}`);\n    bundleId = bundleId.substring(0, typeSeparatorPos);\n  }\n  if (_.isNil(containerRootSupplier)) {\n    const pathInContainer = relativePath;\n    return { bundleId, pathInContainer, containerType };\n  }\n  const containerRoot = _.isFunction(containerRootSupplier)\n    ? await containerRootSupplier(bundleId, containerType)\n    : containerRootSupplier;\n  const pathInContainer = path.posix.resolve(containerRoot, relativePath);\n  verifyIsSubPath(pathInContainer, containerRoot);\n  return {bundleId, pathInContainer, containerType};\n}\n\n/**\n * Save the given base64 data chunk as a binary file on the Simulator under test.\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The remote path on the device. This variable can be prefixed with\n *                              bundle id, so then the file will be uploaded to the corresponding\n *                              application container instead of the default media folder, for example\n *                              '@com.myapp.bla:data/RelativePathInContainer/111.png'. The '@' character at the\n *                              beginning of the argument is mandatory in such case. The colon at the end of bundle identifier\n *                              is optional and is used to distinguish the container type.\n *                              Possible values there are 'app', 'data', 'groups', '<A specific App Group container>'.\n *                              The default value is 'app'.\n *                              The relative folder path is ignored if the file is going to be uploaded\n *                              to the default media folder and only the file name is considered important.\n * @param {string} base64Data - Base-64 encoded content of the file to be uploaded.\n */\nasync function pushFileToSimulator (device, remotePath, base64Data) {\n  const buffer = Buffer.from(base64Data, 'base64');\n  if (CONTAINER_PATH_PATTERN.test(remotePath)) {\n    const {bundleId, pathInContainer: dstPath} = await parseContainerPath(remotePath,\n      async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));\n    log.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` +\n      `Will put the data into '${dstPath}'`);\n    if (!await fs.exists(path.dirname(dstPath))) {\n      log.debug(`The destination folder '${path.dirname(dstPath)}' does not exist. Creating...`);\n      await mkdirp(path.dirname(dstPath));\n    }\n    await fs.writeFile(dstPath, buffer);\n    return;\n  }\n  const dstFolder = await tempDir.openDir();\n  const dstPath = path.resolve(dstFolder, path.basename(remotePath));\n  try {\n    await fs.writeFile(dstPath, buffer);\n    await device.simctl.addMedia(dstPath);\n  } finally {\n    await fs.rimraf(dstFolder);\n  }\n}\n\n/**\n * Save the given base64 data chunk as a binary file on the device under test.\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The remote path on the device. This variable can be prefixed with\n *                              bundle id, so then the file will be uploaded to the corresponding\n *                              application container instead of the default media folder. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              The only supported container type is 'documents'. If the container type is not set\n *                              explicitly for a bundle id, then the default application container is going to be mounted\n *                              (aka --container ifuse argument)\n *                              e.g. If `@com.myapp.bla:documents/111.png` is provided,\n *                                   `On My iPhone/<app name>` in Files app will be mounted in the host machine.\n *                                   Base64 encoded `111.png` will be pushed into `On My iPhone/<app name>/111.png`\n *                                   as base64 decoded data.\n * @param {string} base64Data - Base-64 encoded content of the file to be uploaded.\n */\nasync function pushFileToRealDevice (device, remotePath, base64Data) {\n  const {service, relativePath} = await createService(device.udid, remotePath);\n  try {\n    await pushFile(service, relativePath, base64Data);\n  } catch (e) {\n    log.debug(e.stack);\n    throw new Error(`Could not push the file to '${remotePath}'.  Original error: ${e.message}`);\n  } finally {\n    service.close();\n  }\n}\n\nasync function deleteFileOrFolder (device, remotePath, isSimulator) {\n  return isSimulator\n    ? await deleteFromSimulator(device, remotePath)\n    : await deleteFromRealDevice(device, remotePath);\n}\n\n/**\n * Get the content of given file or folder from iOS Simulator and return it as base-64 encoded string.\n * Folder content is recursively packed into a zip archive.\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The path to a file or a folder, which exists in the corresponding application\n *                              container on Simulator. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              Possible container types are 'app', 'data', 'groups', '<A specific App Group container>'.\n *                              The default type is 'app'.\n * @param {boolean} isFile - Whether the destination item is a file or a folder\n * @returns {string} Base-64 encoded content of the file.\n */\nasync function pullFromSimulator (device, remotePath, isFile) {\n  let pathOnServer;\n  if (CONTAINER_PATH_PATTERN.test(remotePath)) {\n    const {bundleId, pathInContainer: dstPath} = await parseContainerPath(remotePath,\n      async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));\n    log.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` +\n      `Will get the data from '${dstPath}'`);\n    pathOnServer = dstPath;\n  } else {\n    const simRoot = device.getDir();\n    pathOnServer = path.posix.join(simRoot, remotePath);\n    verifyIsSubPath(pathOnServer, simRoot);\n    log.info(`Got the full item path: ${pathOnServer}`);\n  }\n  if (!await fs.exists(pathOnServer)) {\n    log.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);\n  }\n  const buffer = isFile\n    ? await util.toInMemoryBase64(pathOnServer)\n    : await zip.toInMemoryZip(pathOnServer, {encodeToBase64: true});\n  return buffer.toString();\n}\n\n/**\n * Get the content of given file or folder from the real device under test and return it as base-64 encoded string.\n * Folder content is recursively packed into a zip archive.\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The path to an existing remote file on the device. This variable can be prefixed with\n *                              bundle id, so then the file will be downloaded from the corresponding\n *                              application container instead of the default media folder. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              The only supported container type is 'documents'. If the container type is not set\n *                              explicitly for a bundle id, then the default application container is going to be mounted\n *                              (aka --container ifuse argument)\n *                              e.g. If `@com.myapp.bla:documents/111.png` is provided,\n *                                   `On My iPhone/<app name>` in Files app will be mounted in the host machine.\n *                                   `On My iPhone/<app name>/111.png` wil be pulled into the mounted host machine\n *                                   and Appium returns the data as base64-encoded string to client.\n *                                   `@com.myapp.bla:documents/` means `On My iPhone/<app name>`.\n * @param {boolean} isFile - Whether the destination item is a file or a folder\n * @return {string} Base-64 encoded content of the remote file\n */\nasync function pullFromRealDevice (device, remotePath, isFile) {\n  const {service, relativePath} = await createService(device.udid, remotePath);\n  try {\n    const fileInfo = await service.getFileInfo(relativePath);\n    if (isFile && fileInfo.isDirectory()) {\n      throw new Error(`The requested path is not a file. Path: '${remotePath}'`);\n    }\n    if (!isFile && !fileInfo.isDirectory()) {\n      throw new Error(`The requested path is not a folder. Path: '${remotePath}'`);\n    }\n\n    return fileInfo.isFile()\n      ? (await pullFile(service, relativePath)).toString('base64')\n      : (await pullFolder(service, relativePath)).toString();\n  } finally {\n    service.close();\n  }\n}\n\n/**\n * Remove the file or folder from the device\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The path to a file or a folder, which exists in the corresponding application\n *                              container on Simulator. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              Possible container types are 'app', 'data', 'groups', '<A specific App Group container>'.\n *                              The default type is 'app'.\n */\nasync function deleteFromSimulator (device, remotePath) {\n  let pathOnServer;\n  if (CONTAINER_PATH_PATTERN.test(remotePath)) {\n    const {bundleId, pathInContainer: dstPath} = await parseContainerPath(remotePath,\n      async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));\n    log.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` +\n      `'${dstPath}' will be deleted`);\n    pathOnServer = dstPath;\n  } else {\n    const simRoot = device.getDir();\n    pathOnServer = path.posix.join(simRoot, remotePath);\n    verifyIsSubPath(pathOnServer, simRoot);\n    log.info(`Got the full path: ${pathOnServer}`);\n  }\n  if (!await fs.exists(pathOnServer)) {\n    throw new errors.InvalidArgumentError(`The remote path at '${pathOnServer}' does not exist`);\n  }\n  await fs.rimraf(pathOnServer);\n}\n\n/**\n * Remove the file or folder from the device\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The path to an existing remote file on the device. This variable can be prefixed with\n *                              bundle id, so then the file will be downloaded from the corresponding\n *                              application container instead of the default media folder. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              The only supported container type is 'documents'. If the container type is not set\n *                              explicitly for a bundle id, then the default application container is going to be mounted\n *                              (aka --container ifuse argument)\n *                              e.g. If `@com.myapp.bla:documents/111.png` is provided,\n *                                   `On My iPhone/<app name>` in Files app will be mounted in the host machine.\n *                                   `On My iPhone/<app name>/111.png` wil be pulled into the mounted host machine\n *                                   and Appium returns the data as base64-encoded string to client.\n *                                   `@com.myapp.bla:documents/` means `On My iPhone/<app name>`.\n */\nasync function deleteFromRealDevice (device, remotePath) {\n  const { service, relativePath } = await createService(device.udid, remotePath);\n  try {\n    await service.deleteDirectory(relativePath);\n  } catch (e) {\n    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {\n      throw new Error(`Path '${remotePath}' does not exist on the device`);\n    }\n    throw e;\n  } finally {\n    service.close();\n  }\n}\n\n/**\n * Pushes the given data to a file on the remote device\n *\n * @param {string} remotePath The full path to the remote file or\n * a file inside a package bundle. Check the documentation on\n * `pushFileToRealDevice` and `pushFileToSimulator` for more information\n * on acceptable values.\n * @param {string} base64Data Base64 encoded data to be written to the\n * remote file. The remote file will be silently overridden if it already exists.\n * @throws {Error} If there was an error while pushing the data\n */\ncommands.pushFile = async function pushFile (remotePath, base64Data) {\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(`It is expected that remote path points to a file and not to a folder. ` +\n      `'${remotePath}' is given instead`);\n  }\n  if (_.isArray(base64Data)) {\n    // some clients (ahem) java, send a byte array encoding utf8 characters\n    // instead of a string, which would be infinitely better!\n    base64Data = Buffer.from(base64Data).toString('utf8');\n  }\n  return this.isSimulator()\n    ? await pushFileToSimulator(this.opts.device, remotePath, base64Data)\n    : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);\n};\n\n/**\n * @typedef {Object} PushFileOptions\n * @property {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside an app bundle.\n * @property {string} payload Base64-encoded content of the file to be pushed.\n */\n\n/**\n * Pushes the given data to a file on the remote device.\n *\n * @param {PushFileOptions} opts\n */\ncommands.mobilePushFile = async function mobilePushFile (opts = {}) {\n  const { remotePath, payload } = requireArgs(['remotePath', 'payload'], opts);\n  return await this.pushFile(remotePath, payload);\n};\n\n/**\n * Pulls a remote file from the device.\n *\n * @param {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside app bundle.\n * See the documentation for `pullFromRealDevice` and `pullFromSimulator`\n * to get more information on acceptable values.\n * @returns {string} Base64 encoded content of the pulled file\n * @throws {Error} If the pull operation failed\n */\ncommands.pullFile = async function pullFile (remotePath) {\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(`It is expected that remote path points to a file and not to a folder. ` +\n      `'${remotePath}' is given instead`);\n  }\n  return this.isSimulator()\n    ? await pullFromSimulator(this.opts.device, remotePath, true)\n    : await pullFromRealDevice(this.opts.device, remotePath, true);\n};\n\n/**\n * @typedef {Object} PullFileOptions\n * @property {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside app bundle.\n * See the documentation for `pullFromRealDevice` and `pullFromSimulator`\n * to get more information on acceptable values.\n */\n\n/**\n * Pulls a remote file from the device.\n *\n * @param {PullFileOptions} opts\n * @returns {string} The same as in `pullFile`\n */\ncommands.mobilePullFile = async function mobilePullFile (opts = {}) {\n  const { remotePath } = requireArgs('remotePath', opts);\n  return await this.pullFile(remotePath);\n};\n\n/**\n * @typedef {Object} DeleteFolderOptions\n * @property {string} remotePath The full path to the remote folder\n * or a specially formatted path, which points to an item inside app bundle.\n * See the documentation for `pullFromRealDevice` and `pullFromSimulator`\n * to get more information on acceptable values.\n */\n\n/**\n * Delete a remote folder from the device.\n *\n * @param {DeleteFolderOptions} opts\n */\ncommands.mobileDeleteFolder = async function mobileDeleteFolder (opts = {}) {\n  let { remotePath } = requireArgs('remotePath', opts);\n  if (!remotePath.endsWith('/')) {\n    remotePath = `${remotePath}/`;\n  }\n  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());\n};\n\n/**\n * @typedef {Object} DeleteFileOptions\n * @property {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside app bundle.\n * See the documentation for `pullFromRealDevice` and `pullFromSimulator`\n * to get more information on acceptable values.\n */\n\n/**\n * Delete a remote file from the device.\n *\n * @param {DeleteFileOptions} opts\n */\ncommands.mobileDeleteFile = async function mobileDeleteFile (opts = {}) {\n  const { remotePath } = requireArgs('remotePath', opts);\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(`It is expected that remote path points to a file and not to a folder. ` +\n      `'${remotePath}' is given instead`);\n  }\n  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());\n};\n\n/**\n * Pulls the whole folder from the remote device\n *\n * @param {string} remotePath The full path to a folder on the\n * remote device or a folder inside an application bundle\n * @returns {string} Zipped and base64-encoded content of the folder\n * @throws {Error} If there was a failure while getting the folder content\n */\ncommands.pullFolder = async function pullFolder (remotePath) {\n  if (!remotePath.endsWith('/')) {\n    remotePath = `${remotePath}/`;\n  }\n  return this.isSimulator()\n    ? await pullFromSimulator(this.opts.device, remotePath, false)\n    : await pullFromRealDevice(this.opts.device, remotePath, false);\n};\n\n/**\n * @typedef {Object} PullFolderOptions\n * @property {string} remotePath The full path to the remote folder.\n */\n\n/**\n * Pulls the whole folder from the device under test.\n *\n * @param {PullFolderOptions} opts\n * @returns {string} The same as `pullFolder`\n */\ncommands.mobilePullFolder = async function mobilePullFolder (opts = {}) {\n  const { remotePath } = requireArgs('remotePath', opts);\n  return await this.pullFolder(remotePath);\n};\n\nexport { commands, /* for testing */ parseContainerPath };\nexport default commands;\n"],"mappings":"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"}