{"version":3,"file":"pcap.js","names":["MAX_CAPTURE_TIME_SEC","DEFAULT_CAPTURE_TIME_SEC","DEFAULT_EXT","pcapLogger","logger","getLogger","commands","TrafficCapture","constructor","udid","log","resultPath","mainProcess","start","timeoutSeconds","Pyidevice","collectPcap","on","stdout","stderr","info","setTimeout","interrupt","once","code","signal","debug","isCapturing","isRunning","force","interruptPromise","stop","e","warn","message","finish","cleanup","fs","exists","rimraf","mobileStartPcap","options","isSimulator","errorAndThrow","timeLimitSec","forceRestart","_trafficCapture","tempDir","path","prefix","util","uuidV4","substring","suffix","trafficCollector","opts","device","parseInt","isNaN","errors","InvalidArgumentError","mobileStopPcap","encodeBase64OrUpload"],"sources":["../../../lib/commands/pcap.js"],"sourcesContent":["import Pyidevice from '../py-ios-device-client';\nimport { fs, tempDir, logger, util } from 'appium/support';\nimport { encodeBase64OrUpload } from '../utils';\nimport { errors } from 'appium/driver';\n\n\nconst MAX_CAPTURE_TIME_SEC = 60 * 60 * 12;\nconst DEFAULT_CAPTURE_TIME_SEC = 60 * 5;\nconst DEFAULT_EXT = '.pcap';\nconst pcapLogger = logger.getLogger('pcapd');\n\nconst commands = {};\n\n\nclass TrafficCapture {\n  constructor (udid, log, resultPath) {\n    this.udid = udid;\n    this.log = log;\n    this.resultPath = resultPath;\n    this.mainProcess = null;\n  }\n\n  async start (timeoutSeconds) {\n    this.mainProcess = await new Pyidevice(this.udid).collectPcap(this.resultPath);\n    this.mainProcess.on('output', (stdout, stderr) => {\n      if (stderr) {\n        pcapLogger.info(`${stderr}`);\n      }\n    });\n    this.log.info(`Starting network traffic capture session on the device '${this.udid}'. ` +\n      `Will timeout in ${timeoutSeconds}s`);\n    setTimeout(async () => await this.interrupt(), timeoutSeconds * 1000);\n    this.mainProcess.once('exit', (code, signal) => {\n      this.log.debug(`The traffic capture session on the device '${this.udid}' has exited ` +\n        `with code ${code}, signal ${signal}`);\n    });\n  }\n\n  isCapturing () {\n    return !!(this.mainProcess?.isRunning);\n  }\n\n  async interrupt (force = false) {\n    if (this.isCapturing()) {\n      const interruptPromise = this.mainProcess.stop(force ? 'SIGTERM' : 'SIGINT');\n      this.mainProcess = null;\n      try {\n        await interruptPromise;\n      } catch (e) {\n        this.log.warn(`Cannot ${force ? 'terminate' : 'interrupt'} the traffic capture session. ` +\n          `Original error: ${e.message}`);\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  async finish () {\n    await this.interrupt();\n    return this.resultPath;\n  }\n\n  async cleanup () {\n    if (await fs.exists(this.resultPath)) {\n      await fs.rimraf(this.resultPath);\n    }\n  }\n}\n\n\n/**\n * @typedef {Object} StartCaptureOptions\n *\n * @property {?string|number} timeLimitSec [180] - The maximum traffic capture time, in seconds.\n * The default value is 180, the maximum value is 43200 (12 hours).\n * @property {?boolean} forceRestart [false] - Whether to restart audio capture process forcefully when\n * startPcap is called (`true`) or ignore the call until the current network traffic capture is completed.\n */\n\n/**\n * Records the given network traffic capture into a .pcap file.\n *\n * @param {?StartCaptureOptions} options - The available options.\n * @throws {Error} If network traffic capture has failed to start.\n */\ncommands.mobileStartPcap = async function mobileStartPcap (options = {}) {\n  if (this.isSimulator()) {\n    this.log.errorAndThrow('Network traffic capture only works on real devices');\n  }\n\n  const {\n    timeLimitSec = DEFAULT_CAPTURE_TIME_SEC,\n    forceRestart,\n  } = options;\n\n  if (this._trafficCapture?.isCapturing()) {\n    this.log.info(`There is an active traffic capture process`);\n    if (forceRestart) {\n      this.log.info(`Stopping it because 'forceRestart' option is set to true`);\n      await this._trafficCapture.interrupt(true);\n    } else {\n      this.log.info(`Doing nothing. ` +\n        `Set 'forceRestart' option to true if you'd like to start a new traffic capture session`);\n      return;\n    }\n  }\n  if (this._trafficCapture) {\n    await this._trafficCapture.cleanup();\n    this._trafficCapture = null;\n  }\n\n  const resultPath = await tempDir.path({\n    prefix: `appium_${util.uuidV4().substring(0, 8)}`,\n    suffix: DEFAULT_EXT,\n  });\n\n  const trafficCollector = new TrafficCapture(this.opts.device.udid, this.log, resultPath);\n\n  const timeoutSeconds = parseInt(timeLimitSec, 10);\n  if (isNaN(timeoutSeconds) || timeoutSeconds > MAX_CAPTURE_TIME_SEC || timeoutSeconds <= 0) {\n    throw new errors.InvalidArgumentError(`The timeLimitSec value must be in range [1, ${MAX_CAPTURE_TIME_SEC}] seconds. ` +\n      `The value of '${timeLimitSec}' has been passed instead.`);\n  }\n\n  try {\n    await trafficCollector.start(timeoutSeconds);\n  } catch (e) {\n    await trafficCollector.interrupt(true);\n    await trafficCollector.cleanup();\n    throw e;\n  }\n  this._trafficCapture = trafficCollector;\n};\n\n/**\n * Stop capture of the device network traffic. If no traffic capture process is running then\n * the endpoint will try to get the recently recorded file.\n * If no previously recorded file is found and no active traffic capture\n * processes are running then the method returns an empty string.\n *\n * @returns {string} Base64-encoded content of the recorded pcap file or an\n * empty string if no traffic capture has been started before.\n * @throws {Error} If there was an error while getting the capture file.\n */\ncommands.mobileStopPcap = async function mobileStopPcap () {\n  if (!this._trafficCapture) {\n    this.log.info('Network traffic collector has not been started. There is nothing to stop');\n    return '';\n  }\n\n  let resultPath;\n  try {\n    resultPath = await this._trafficCapture.finish();\n    if (!await fs.exists(resultPath)) {\n      this.log.errorAndThrow(`The network traffic capture utility has failed ` +\n        `to store the actual traffic capture at '${resultPath}'`);\n    }\n  } catch (e) {\n    await this._trafficCapture.interrupt(true);\n    await this._trafficCapture.cleanup();\n    this._trafficCapture = null;\n    throw e;\n  }\n  return await encodeBase64OrUpload(resultPath);\n};\n\nexport { commands };\nexport default commands;\n"],"mappings":"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"}