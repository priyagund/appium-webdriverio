{"version":3,"file":"recordscreen.js","names":["commands","MAX_RECORDING_TIME_SEC","DEFAULT_RECORDING_TIME_SEC","DEFAULT_MJPEG_SERVER_PORT","DEFAULT_FPS","DEFAULT_QUALITY","DEFAULT_VCODEC","MP4_EXT","FFMPEG_BINARY","ffmpegLogger","logger","getLogger","QUALITY_MAPPING","low","medium","high","photo","ScreenRecorder","constructor","udid","log","videoPath","opts","mainProcess","timeoutHandler","start","timeoutMs","fs","which","err","Error","remotePort","remoteUrl","usePortForwarding","videoFps","videoType","videoScale","videoFilters","pixelFormat","DEVICE_CONNECTIONS_FACTORY","requestConnection","devicePort","warn","args","push","protocol","hostname","url","parse","SubProcess","isCaptureStarted","on","stdout","stderr","trim","startsWith","info","startupTimeout","waitForCondition","waitMs","intervalMs","e","isRunning","join","setTimeout","interrupt","force","result","clearTimeout","interruptPromise","stop","message","releaseConnection","finish","cleanup","exists","rimraf","startRecordingScreen","options","timeLimit","videoQuality","forceRestart","stopRecordingScreen","tempDir","path","prefix","Math","random","toString","substring","suffix","wdaBaseUrl","WDA_BASE_URL","screenRecorder","device","mjpegServerPort","isRealDevice","isLocalHost","errorAndThrow","_recentScreenRecorder","timeoutSeconds","parseFloat","isNaN","mjpegServerScreenshotQuality","mjpegServerFramerate","proxyCommand","quality","_","isInteger","toLower","JSON","stringify","keys","undefined","fps","parseInt","util","hasValue","settings","encodeBase64OrUpload","remotePath"],"sources":["../../../lib/commands/recordscreen.js"],"sourcesContent":["import _ from 'lodash';\nimport { fs, tempDir, logger, util } from 'appium/support';\nimport { SubProcess } from 'teen_process';\nimport { encodeBase64OrUpload, isLocalHost } from '../utils';\nimport DEVICE_CONNECTIONS_FACTORY from '../device-connections-factory';\nimport { WDA_BASE_URL } from 'appium-webdriveragent';\nimport { waitForCondition } from 'asyncbox';\nimport url from 'url';\n\nlet commands = {};\n\nconst MAX_RECORDING_TIME_SEC = 60 * 30;\nconst DEFAULT_RECORDING_TIME_SEC = 60 * 3;\nconst DEFAULT_MJPEG_SERVER_PORT = 9100;\nconst DEFAULT_FPS = 10;\nconst DEFAULT_QUALITY = 'medium';\nconst DEFAULT_VCODEC = 'mjpeg';\nconst MP4_EXT = '.mp4';\nconst FFMPEG_BINARY = 'ffmpeg';\nconst ffmpegLogger = logger.getLogger(FFMPEG_BINARY);\nconst QUALITY_MAPPING = {\n  low: 10,\n  medium: 25,\n  high: 75,\n  photo: 100,\n};\n\n\nclass ScreenRecorder {\n  constructor (udid, log, videoPath, opts = {}) {\n    this.videoPath = videoPath;\n    this.log = log;\n    this.opts = opts;\n    this.udid = udid;\n    this.mainProcess = null;\n    this.timeoutHandler = null;\n  }\n\n  async start (timeoutMs) {\n    try {\n      await fs.which(FFMPEG_BINARY);\n    } catch (err) {\n      throw new Error(`'${FFMPEG_BINARY}' binary is not found in PATH. Install it using 'brew install ffmpeg'. ` +\n        `Check https://www.ffmpeg.org/download.html for more details.`);\n    }\n\n    const {\n      remotePort,\n      remoteUrl,\n      usePortForwarding,\n      videoFps,\n      videoType,\n      videoScale,\n      videoFilters,\n      pixelFormat,\n    } = this.opts;\n\n    try {\n      await DEVICE_CONNECTIONS_FACTORY.requestConnection(this.udid, remotePort, {\n        devicePort: remotePort,\n        usePortForwarding,\n      });\n    } catch (err) {\n      this.log.warn(`Cannot forward the local port ${remotePort} to ${remotePort} ` +\n        `on the device ${this.udid}. Set the custom value to 'mjpegServerPort' ` +\n        `capability if this is an undesired behavior.`);\n    }\n\n    const args = [\n      '-f', 'mjpeg',\n      // https://github.com/appium/appium/issues/16294\n      '-reconnect', '1',\n      '-reconnect_at_eof', '1',\n      '-reconnect_streamed', '1',\n      '-reconnect_delay_max', `${timeoutMs / 1000 + 1}`,\n    ];\n    //Parameter `-r` is optional. See details: https://github.com/appium/appium/issues/12067\n    if (videoFps && videoType === 'libx264') {\n      args.push('-r', videoFps);\n    }\n    const {protocol, hostname} = url.parse(remoteUrl);\n    args.push('-i', `${protocol}//${hostname}:${remotePort}`);\n    if (videoFilters || videoScale) {\n      args.push('-vf', videoFilters || `scale=${videoScale}`);\n    }\n    // Quicktime compatibility via pixelFormat: 'yuv420p'\n    if (pixelFormat) {\n      args.push('-pix_fmt', pixelFormat);\n    }\n    args.push(\n      '-vcodec', videoType,\n      '-y', this.videoPath\n    );\n\n    this.mainProcess = new SubProcess(FFMPEG_BINARY, args);\n    let isCaptureStarted = false;\n    this.mainProcess.on('output', (stdout, stderr) => {\n      if (stderr) {\n        if (stderr.trim().startsWith('frame=')) {\n          if (!isCaptureStarted) {\n            isCaptureStarted = true;\n          }\n        } else {\n          ffmpegLogger.info(`${stderr}`);\n        }\n      }\n    });\n    await this.mainProcess.start(0);\n    const startupTimeout = 5000;\n    try {\n      await waitForCondition(() => isCaptureStarted, {\n        waitMs: startupTimeout,\n        intervalMs: 300,\n      });\n    } catch (e) {\n      this.log.warn(`Screen capture process did not start within ${startupTimeout}ms. Continuing anyway`);\n    }\n    if (!this.mainProcess.isRunning) {\n      throw new Error(`The screen capture process '${FFMPEG_BINARY}' died unexpectedly. ` +\n        `Check server logs for more details`);\n    }\n    this.log.info(`Starting screen capture on the device '${this.udid}' with command: '${FFMPEG_BINARY} ${args.join(' ')}'. ` +\n      `Will timeout in ${timeoutMs}ms`);\n\n    this.timeoutHandler = setTimeout(async () => {\n      if (!await this.interrupt()) {\n        this.log.warn(`Cannot finish the active screen recording on the device '${this.udid}' after ${timeoutMs}ms timeout`);\n      }\n    }, timeoutMs);\n  }\n\n  async interrupt (force = false) {\n    let result = true;\n\n    if (this.timeoutHandler) {\n      clearTimeout(this.timeoutHandler);\n      this.timeoutHandler = null;\n    }\n\n    if (this.mainProcess && this.mainProcess.isRunning) {\n      const interruptPromise = this.mainProcess.stop(force ? 'SIGTERM' : 'SIGINT');\n      this.mainProcess = null;\n      try {\n        await interruptPromise;\n      } catch (e) {\n        this.log.warn(`Cannot ${force ? 'terminate' : 'interrupt'} ${FFMPEG_BINARY}. ` +\n          `Original error: ${e.message}`);\n        result = false;\n      }\n    }\n\n    DEVICE_CONNECTIONS_FACTORY.releaseConnection(this.udid, this.opts.remotePort);\n\n    return result;\n  }\n\n  async finish () {\n    await this.interrupt();\n    return this.videoPath;\n  }\n\n  async cleanup () {\n    if (await fs.exists(this.videoPath)) {\n      await fs.rimraf(this.videoPath);\n    }\n  }\n}\n\n\n/**\n * @typedef {Object} StartRecordingOptions\n *\n * @property {?string} remotePath - The path to the remote location, where the resulting video should be uploaded.\n *                                  The following protocols are supported: http/https, ftp.\n *                                  Null or empty string value (the default setting) means the content of resulting\n *                                  file should be encoded as Base64 and passed as the endpoint response value.\n *                                  An exception will be thrown if the generated media file is too big to\n *                                  fit into the available process memory.\n *                                  This option only has an effect if there is screen recording process in progress\n *                                  and `forceRestart` parameter is not set to `true`.\n * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.\n * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.\n * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.\n *                              Only works if `remotePath` is provided.\n * @property {?string} videoType - The video codec type used for encoding of the be recorded screen capture.\n *                                 Execute `ffmpeg -codecs` in the terminal to see the list of supported video codecs.\n *                                 'mjpeg' by default.\n * @property {?string|number} videoQuality - The video encoding quality (low, medium, high, photo - defaults to medium).\n * @property {?string|number} videoFps - The Frames Per Second rate of the recorded video. Change this value if the resulting video\n *                                is too slow or too fast. Defaults to 10.\n * @property {?string} videoFilters - The FFMPEG video filters to apply. These filters allow to scale, flip, rotate and do many\n *                                    other useful transformations on the source video stream. The format of the property\n *                                    must comply with https://ffmpeg.org/ffmpeg-filters.html\n * @property {?string} videoScale - The scaling value to apply. Read https://trac.ffmpeg.org/wiki/Scaling for possible values.\n *                                  No scale is applied by default. If both `videoFilters` and `videoScale` are set then\n *                                  only `videoFilters` value will be respected.\n * @property {?string} pixelFormat - Output pixel format. Run `ffmpeg -pix_fmts` to list possible values.\n *                                   For Quicktime compatibility, set to \"yuv420p\" along with videoType: \"libx264\".\n * @property {?boolean} forceRestart - Whether to try to catch and upload/return the currently running screen recording\n *                                     (`false`, the default setting) or ignore the result of it and start a new recording\n *                                     immediately.\n * @property {?string|number} timeLimit - The maximum recording time, in seconds.\n *                                        The default value is 180, the maximum value is 600 (10 minutes).\n */\n\n/**\n * Record the display of devices running iOS Simulator since Xcode 9 or real devices since iOS 11\n * (ffmpeg utility is required: 'brew install ffmpeg').\n * It records screen activity to a MPEG-4 file. Audio is not recorded with the video file.\n * If screen recording has been already started then the command will stop it forcefully and start a new one.\n * The previously recorded video file will be deleted.\n *\n * @param {?StartRecordingOptions} options - The available options.\n * @returns {string} Base64-encoded content of the recorded media file if\n *                   any screen recording is currently running or an empty string.\n * @throws {Error} If screen recording has failed to start.\n */\ncommands.startRecordingScreen = async function startRecordingScreen (options = {}) {\n  const {\n    videoType = DEFAULT_VCODEC,\n    timeLimit = DEFAULT_RECORDING_TIME_SEC,\n    videoQuality = DEFAULT_QUALITY,\n    videoFps = DEFAULT_FPS,\n    videoFilters,\n    videoScale,\n    forceRestart,\n    pixelFormat\n  } = options;\n\n  let result = '';\n  if (!forceRestart) {\n    this.log.info(`Checking if there is/was a previous screen recording. ` +\n      `Set 'forceRestart' option to 'true' if you'd like to skip this step.`);\n    result = await this.stopRecordingScreen(options);\n  }\n\n  const videoPath = await tempDir.path({\n    prefix: `appium_${Math.random().toString(16).substring(2, 8)}`,\n    suffix: MP4_EXT,\n  });\n\n  const wdaBaseUrl = this.opts.wdaBaseUrl || WDA_BASE_URL;\n  const screenRecorder = new ScreenRecorder(this.opts.device.udid, this.log, videoPath, {\n    remotePort: this.opts.mjpegServerPort || DEFAULT_MJPEG_SERVER_PORT,\n    remoteUrl: wdaBaseUrl,\n    usePortForwarding: this.isRealDevice() && isLocalHost(wdaBaseUrl),\n    videoType,\n    videoFilters,\n    videoScale,\n    videoFps,\n    pixelFormat\n  });\n  if (!await screenRecorder.interrupt(true)) {\n    this.log.errorAndThrow('Unable to stop screen recording process');\n  }\n  if (this._recentScreenRecorder) {\n    await this._recentScreenRecorder.cleanup();\n    this._recentScreenRecorder = null;\n  }\n\n  const timeoutSeconds = parseFloat(timeLimit);\n  if (isNaN(timeoutSeconds) || timeoutSeconds > MAX_RECORDING_TIME_SEC || timeoutSeconds <= 0) {\n    this.log.errorAndThrow(`The timeLimit value must be in range [1, ${MAX_RECORDING_TIME_SEC}] seconds. ` +\n      `The value of '${timeLimit}' has been passed instead.`);\n  }\n\n  let {\n    mjpegServerScreenshotQuality,\n    mjpegServerFramerate,\n  } = await this.proxyCommand('/appium/settings', 'GET');\n  if (videoQuality) {\n    const quality = _.isInteger(videoQuality) ? videoQuality : QUALITY_MAPPING[_.toLower(videoQuality)];\n    if (!quality) {\n      throw new Error(`videoQuality value should be one of ${JSON.stringify(_.keys(QUALITY_MAPPING))} or a number in range 1..100. ` +\n        `'${videoQuality}' is given instead`);\n    }\n    mjpegServerScreenshotQuality = mjpegServerScreenshotQuality !== quality ? quality : undefined;\n  } else {\n    mjpegServerScreenshotQuality = undefined;\n  }\n  if (videoFps) {\n    const fps = parseInt(videoFps, 10);\n    if (isNaN(fps)) {\n      throw new Error(`videoFps value should be a valid number in range 1..60. ` +\n        `'${videoFps}' is given instead`);\n    }\n    mjpegServerFramerate = mjpegServerFramerate !== fps ? fps : undefined;\n  } else {\n    mjpegServerFramerate = undefined;\n  }\n  if (util.hasValue(mjpegServerScreenshotQuality) || util.hasValue(mjpegServerFramerate)) {\n    await this.proxyCommand('/appium/settings', 'POST', {\n      settings: {\n        mjpegServerScreenshotQuality,\n        mjpegServerFramerate,\n      }\n    });\n  }\n\n  try {\n    await screenRecorder.start(timeoutSeconds * 1000);\n  } catch (e) {\n    await screenRecorder.interrupt(true);\n    await screenRecorder.cleanup();\n    throw e;\n  }\n  this._recentScreenRecorder = screenRecorder;\n\n  return result;\n};\n\n/**\n * @typedef {Object} StopRecordingOptions\n *\n * @property {?string} remotePath - The path to the remote location, where the resulting video should be uploaded.\n *                                  The following protocols are supported: http/https, ftp.\n *                                  Null or empty string value (the default setting) means the content of resulting\n *                                  file should be encoded as Base64 and passed as the endpoint response value.\n *                                  An exception will be thrown if the generated media file is too big to\n *                                  fit into the available process memory.\n * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.\n * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.\n * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.\n *                              Only works if `remotePath` is provided.\n * @property {?Object} headers - Additional headers mapping for multipart http(s) uploads\n * @property {?string} fileFieldName [file] - The name of the form field, where the file content BLOB should be stored for\n *                                            http(s) uploads\n * @property {?Object|Array<Pair>} formFields - Additional form fields for multipart http(s) uploads\n */\n\n/**\n * Stop recording the screen. If no screen recording process is running then\n * the endpoint will try to get the recently recorded file.\n * If no previously recorded file is found and no active screen recording\n * processes are running then the method returns an empty string.\n *\n * @param {?StopRecordingOptions} options - The available options.\n * @returns {string} Base64-encoded content of the recorded media file if 'remotePath'\n *                   parameter is empty or null or an empty string.\n * @throws {Error} If there was an error while getting the name of a media file\n *                 or the file content cannot be uploaded to the remote location.\n */\ncommands.stopRecordingScreen = async function stopRecordingScreen (options = {}) {\n  if (!this._recentScreenRecorder) {\n    this.log.info('Screen recording is not running. There is nothing to stop.');\n    return '';\n  }\n\n  try {\n    const videoPath = await this._recentScreenRecorder.finish();\n    if (!await fs.exists(videoPath)) {\n      this.log.errorAndThrow(`The screen recorder utility has failed ` +\n        `to store the actual screen recording at '${videoPath}'`);\n    }\n    return await encodeBase64OrUpload(videoPath, options.remotePath, options);\n  } finally {\n    await this._recentScreenRecorder.interrupt(true);\n    await this._recentScreenRecorder.cleanup();\n    this._recentScreenRecorder = null;\n  }\n};\n\n\nexport { commands };\nexport default commands;\n"],"mappings":"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"}