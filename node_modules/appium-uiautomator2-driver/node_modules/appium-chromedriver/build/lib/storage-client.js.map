{"version":3,"file":"storage-client.js","names":["TIMEOUT_MS","MAX_PARALLEL_DOWNLOADS","log","logger","getLogger","isCrcOk","src","checksum","md5","fs","hash","_","toLower","findChildNode","parent","childName","text","hasChildNodes","childNodeIdx","childNodes","length","childNode","localName","childText","extractNodeText","node","firstChild","util","hasValue","nodeValue","ChromedriverStorageClient","constructor","args","chromedriverDir","getChromedriverDir","timeout","mapping","parseNotes","content","result","versionMatch","exec","version","minBrowserVersionMatch","minBrowserVersion","retrieveAdditionalDriverInfo","driverKey","notesUrl","infoDict","notes","retrieveData","accept","debug","parseStorageXml","doc","shouldParseNotes","driverNodes","xpath","select","isEmpty","promises","driverNode","key","includes","etag","cdInfo","url","CD_CDN","trim","first","split","notesPath","isNotesPresent","reduce","acc","info","push","B","all","size","retrieveMapping","xml","DOMParser","parseFromString","cloneDeep","unzipDriver","dst","tmpRoot","tempDir","openDir","zip","extractAllTo","chromedriverPath","walkDir","itemPath","isDirectory","path","parse","name","Error","basename","mv","mkdirp","rimraf","selectMatchingDrivers","osInfo","opts","versions","driversToSync","keys","filter","cdName","pluralize","isNaN","minBrowserVersionInt","parseInt","closestMatchedVersionNumber","currentMinBrowserVersion","uniq","map","arch","hardwareName","X64","some","X86","OS","mac","M1_ARCH_SUFFIX","platformRe","RegExp","test","retrieveDriver","index","archivesRoot","isStrict","archivePath","resolve","net","downloadFile","isMetered","e","msg","message","error","fileName","system","isWindows","targetPath","chmod","syncDrivers","getOsInfo","JSON","stringify","synchronizedDrivers","idx","entries"],"sources":["../../lib/storage-client.js"],"sourcesContent":["import {\n  getChromedriverDir, CD_CDN, retrieveData, getOsInfo,\n  OS, X64, X86, M1_ARCH_SUFFIX,\n} from './utils';\nimport _ from 'lodash';\nimport xpath from 'xpath';\nimport { DOMParser } from '@xmldom/xmldom';\nimport B from 'bluebird';\nimport path from 'path';\nimport { system, fs, logger, tempDir, zip, util, net } from 'appium/support';\n\n\nconst TIMEOUT_MS = 15000;\nconst MAX_PARALLEL_DOWNLOADS = 5;\n\nconst log = logger.getLogger('ChromedriverStorageClient');\n\n\nasync function isCrcOk (src, checksum) {\n  const md5 = await fs.hash(src, 'md5');\n  return _.toLower(md5) === _.toLower(checksum);\n}\n\nfunction findChildNode (parent, childName = null, text = null) {\n  if (!childName && !text) {\n    return null;\n  }\n  if (!parent.hasChildNodes()) {\n    return null;\n  }\n\n  for (let childNodeIdx = 0; childNodeIdx < parent.childNodes.length; childNodeIdx++) {\n    const childNode = parent.childNodes[childNodeIdx];\n    if (childName && !text && childName === childNode.localName) {\n      return childNode;\n    }\n    if (text) {\n      const childText = extractNodeText(childNode);\n      if (!childText) {\n        continue;\n      }\n      if (childName && childName === childNode.localName && text === childText) {\n        return childNode;\n      }\n      if (!childName && text === childText) {\n        return childNode;\n      }\n    }\n  }\n  return null;\n}\n\nfunction extractNodeText (node) {\n  return (!node || !node.firstChild || !util.hasValue(node.firstChild.nodeValue))\n    ? null\n    : node.firstChild.nodeValue;\n}\n\n\nclass ChromedriverStorageClient {\n  constructor (args = {}) {\n    const {\n      chromedriverDir = getChromedriverDir(),\n      timeout = TIMEOUT_MS,\n    } = args;\n    this.chromedriverDir = chromedriverDir;\n    this.timeout = timeout;\n    this.mapping = {};\n  }\n\n  /**\n   * @typedef {Object} AdditionalDriverDetails\n   * @property {?string} version - Chromedriver version\n   * or `null` if it cannot be found\n   * @property {?string} minBrowserVersion - The minimum browser version\n   * supported by chromedriver or `null` if it cannot be found\n   */\n\n  /**\n   * Gets additional chromedriver details from chromedriver\n   * release notes\n   *\n   * @param {string} content - Release notes of the corresponding chromedriver\n   * @returns {AdditionalDriverDetails}\n   */\n  parseNotes (content) {\n    const result = {};\n    const versionMatch = /^\\s*[-]+ChromeDriver[\\D]+([\\d.]+)/im.exec(content);\n    if (versionMatch) {\n      result.version = versionMatch[1];\n    }\n    const minBrowserVersionMatch = /^\\s*Supports Chrome[\\D]+(\\d+)/im.exec(content);\n    if (minBrowserVersionMatch) {\n      result.minBrowserVersion = minBrowserVersionMatch[1];\n    }\n    return result;\n  }\n\n  /**\n   * Downloads chromedriver release notes and puts them\n   * into the dictionary argument\n   *\n   * @param {string} driverKey - Driver version plus archive name\n   * @param {string} notesUrl - The URL of chromedriver notes\n   * @param {Object} infoDict - The dictionary containing driver info.\n   * The method call mutates by merging `AdditionalDriverDetails`\n   * @throws {Error} if the release notes cannot be downloaded\n   */\n  async retrieveAdditionalDriverInfo (driverKey, notesUrl, infoDict) {\n    const notes = await retrieveData(notesUrl, {\n      'user-agent': 'appium',\n      accept: '*/*',\n    }, { timeout: this.timeout });\n    const { minBrowserVersion } = this.parseNotes(notes);\n    if (!minBrowserVersion) {\n      log.debug(`The driver '${driverKey}' does not contain valid release notes at ${notesUrl}. ` +\n        `Skipping it`);\n      return;\n    }\n    infoDict.minBrowserVersion = minBrowserVersion;\n  }\n\n  /**\n   * Parses chromedriver storage XML and stores\n   * the parsed results into `this.mapping`\n   *\n   * @param {DOMDocument} doc - The DOM representation\n   * of the chromedriver storage XML\n   * @param {boolean} shouldParseNotes [true] - If set to `true`\n   * then additional drivers information is going to be parsed\n   * and assigned to `this.mapping`\n   */\n  async parseStorageXml (doc, shouldParseNotes = true) {\n    const driverNodes = xpath.select(`//*[local-name(.)='Contents']`, doc);\n    log.debug(`Parsed ${driverNodes.length} entries from storage XML`);\n    if (_.isEmpty(driverNodes)) {\n      return;\n    }\n\n    const promises = [];\n    for (const driverNode of driverNodes) {\n      const key = extractNodeText(findChildNode(driverNode, 'Key'));\n      if (!_.includes(key, '/chromedriver_')) {\n        continue;\n      }\n\n      const etag = extractNodeText(findChildNode(driverNode, 'ETag'));\n      if (!etag) {\n        log.debug(`The entry '${key}' does not contain the checksum. Skipping it`);\n        continue;\n      }\n\n      const cdInfo = {\n        url: `${CD_CDN}/${key}`,\n        etag: _.trim(etag, '\"'),\n        version: _.first(key.split('/')),\n      };\n      this.mapping[key] = cdInfo;\n\n      const notesPath = `${cdInfo.version}/notes.txt`;\n      const isNotesPresent = !!driverNodes\n        .reduce((acc, node) => acc || findChildNode(node, 'Key', notesPath), false);\n      if (!isNotesPresent) {\n        cdInfo.minBrowserVersion = null;\n        if (shouldParseNotes) {\n          log.info(`The entry '${key}' does not contain any notes. Skipping it`);\n        }\n        continue;\n      } else if (!shouldParseNotes) {\n        continue;\n      }\n\n      promises.push(this.retrieveAdditionalDriverInfo(key, `${CD_CDN}/${notesPath}`, cdInfo));\n      if (promises.length % MAX_PARALLEL_DOWNLOADS === 0) {\n        await B.all(promises);\n      }\n    }\n    await B.all(promises);\n    log.info(`The total count of entries in the mapping: ${_.size(this.mapping)}`);\n  }\n\n  /**\n   * @typedef {Object} DriverDetails\n   * @property {string} url - The full url to the corresponding driver in\n   * the remote storage\n   * @property {string} etag - The CRC of the driver archive\n   * @property {string} version - Chromedriver version\n   */\n\n  /**\n   * @typedef {Object} ChromedriversMapping\n   * @property {DriverDetails} - The keys are unique driver identifiers\n   * (version/archive name). The corresponding values have `DriverDetails`\n   * containing chromedriver details\n   */\n\n  /**\n   * Retrieves chromedriver mapping from the storage\n   *\n   * @param {boolean} shouldParseNotes [true] - if set to `true`\n   * then additional chromedrivers info is going to be retrieved and\n   * parsed from release notes\n   * @returns {ChromedriversMapping}\n   */\n  async retrieveMapping (shouldParseNotes = true) {\n    const xml = await retrieveData(CD_CDN, {\n      'user-agent': 'appium',\n      accept: 'application/xml, */*',\n    }, { timeout: this.timeout });\n    const doc = new DOMParser().parseFromString(xml);\n    await this.parseStorageXml(doc, shouldParseNotes);\n    return _.cloneDeep(this.mapping);\n  }\n\n  /**\n   * Extracts downloaded chromedriver archive\n   * into the given destination\n   *\n   * @param {string} src - The source archive path\n   * @param {string} dst - The destination chromedriver path\n   */\n  async unzipDriver (src, dst) {\n    const tmpRoot = await tempDir.openDir();\n    try {\n      await zip.extractAllTo(src, tmpRoot);\n      const chromedriverPath = await fs.walkDir(tmpRoot, true, (itemPath, isDirectory) =>\n        !isDirectory && _.toLower(path.parse(itemPath).name) === 'chromedriver');\n      if (!chromedriverPath) {\n        throw new Error('The archive was unzipped properly, but we could not find any chromedriver executable');\n      }\n      log.debug(`Moving the extracted '${path.basename(chromedriverPath)}' to '${dst}'`);\n      await fs.mv(chromedriverPath, dst, {\n        mkdirp: true\n      });\n    } finally {\n      await fs.rimraf(tmpRoot);\n    }\n  }\n\n  /**\n   * @typedef {Object} OSInfo\n   * @property {string} name - The name of the host OS\n   * Can be either `mac`, `windows` or `linux`\n   * @property {string} arch - The architecture of the host OD.\n   * Can be either `32` or `64`\n   * @property {?string} hardwareName - The output of `uname -m` command\n   * on linux and mac systems. `null` on Windows\n   */\n\n  /**\n   * Filters `this.mapping` to only select matching\n   * chromedriver entries by operating system information\n   * and/or additional synchronization options (if provided)\n   *\n   * @param {?OSInfo} osInfo\n   * @param {?SyncOptions} opts\n   * @returns {Array<String>} The list of filtered chromedriver\n   * entry names (version/archive name)\n   */\n  selectMatchingDrivers (osInfo, opts = {}) {\n    const {\n      minBrowserVersion,\n      versions = [],\n    } = opts;\n    let driversToSync = _.keys(this.mapping);\n\n    if (!_.isEmpty(versions)) {\n      // Handle only selected versions if requested\n      log.debug(`Selecting chromedrivers whose versions match to ${versions}`);\n      driversToSync = driversToSync\n        .filter((cdName) => versions.includes(`${this.mapping[cdName].version}`));\n\n      log.debug(`Got ${util.pluralize('item', driversToSync.length, true)}`);\n      if (_.isEmpty(driversToSync)) {\n        return [];\n      }\n    }\n\n    if (!isNaN(minBrowserVersion)) {\n      // Only select drivers that support the current browser whose major version number equals to `minBrowserVersion`\n      const minBrowserVersionInt = parseInt(minBrowserVersion, 10);\n      log.debug(`Selecting chromedrivers whose minimum supported browser version matches to ${minBrowserVersionInt}`);\n      let closestMatchedVersionNumber = 0;\n      // Select the newest available and compatible chromedriver\n      for (const cdName of driversToSync) {\n        const currentMinBrowserVersion = parseInt(this.mapping[cdName].minBrowserVersion, 10);\n        if (!isNaN(currentMinBrowserVersion)\n            && currentMinBrowserVersion <= minBrowserVersionInt\n            && closestMatchedVersionNumber < currentMinBrowserVersion) {\n          closestMatchedVersionNumber = currentMinBrowserVersion;\n        }\n      }\n      driversToSync = driversToSync.filter((cdName) => `${this.mapping[cdName].minBrowserVersion}` ===\n        `${closestMatchedVersionNumber > 0 ? closestMatchedVersionNumber : minBrowserVersionInt}`);\n\n      log.debug(`Got ${util.pluralize('item', driversToSync.length, true)}`);\n      if (_.isEmpty(driversToSync)) {\n        return [];\n      }\n      log.debug(`Will select candidate ${util.pluralize('driver', driversToSync.length)} ` +\n        `versioned as '${_.uniq(driversToSync.map((cdName) => this.mapping[cdName].version))}'`);\n    }\n\n    if (!_.isEmpty(osInfo)) {\n      // Filter out drivers for unsupported system architectures\n      let {name, arch, hardwareName} = osInfo;\n      if (arch === X64 && !driversToSync.some((cdName) => cdName.includes(`_${name}${X64}`))) {\n        // Fall back to x86 build if x64 one is not available for the given OS\n        arch = X86;\n      }\n      if (name === OS.mac && _.includes(hardwareName, 'arm')\n          && driversToSync.some((cdName) => cdName.includes(M1_ARCH_SUFFIX))) {\n        // prefer executable for M1 arch if present\n        arch += M1_ARCH_SUFFIX;\n      }\n      log.debug(`Selecting chromedrivers whose platform matches to ${name}${arch}`);\n      const platformRe = new RegExp(`(\\\\b|_)${name}${arch}\\\\b`);\n      driversToSync = driversToSync.filter((cdName) => platformRe.test(cdName));\n      log.debug(`Got ${util.pluralize('item', driversToSync.length, true)}`);\n    }\n\n    return driversToSync;\n  }\n\n  /**\n   * Retrieves the given chromedriver from the storage\n   * and unpacks it into `this.chromedriverDir` folder\n   *\n   * @param {number} index - The unique driver index\n   * @param {string} driverKey - The driver key in `this.mapping`\n   * @param {string} archivesRoot - The temporary folder path to extract\n   * downloaded archives to\n   * @param {boolean} isStrict [true] - Whether to throw an error (`true`)\n   * or return a boolean result if the driver retrieval process fails\n   * @throws {Error} if there was a failure while retrieving the driver\n   * and `isStrict` is set to `true`\n   * @returns {boolean} if `true` then the chromedriver is successfully\n   * downloaded and extracted.\n   */\n  async retrieveDriver (index, driverKey, archivesRoot, isStrict = false) {\n    const { url, etag, version } = this.mapping[driverKey];\n    const archivePath = path.resolve(archivesRoot, `${index}.zip`);\n    log.debug(`Retrieving '${url}' to '${archivePath}'`);\n    try {\n      await net.downloadFile(url, archivePath, {\n        isMetered: false,\n        timeout: TIMEOUT_MS\n      });\n    } catch (e) {\n      const msg = `Cannot download chromedriver archive. Original error: ${e.message}`;\n      if (isStrict) {\n        throw new Error(msg);\n      }\n      log.error(msg);\n      return false;\n    }\n    if (!await isCrcOk(archivePath, etag)) {\n      const msg = `The checksum for the downloaded chromedriver '${driverKey}' did not match`;\n      if (isStrict) {\n        throw new Error(msg);\n      }\n      log.error(msg);\n      return false;\n    }\n    const fileName = `${path.parse(url).name}_v${version}` +\n      (system.isWindows() ? '.exe' : '');\n    const targetPath = path.resolve(this.chromedriverDir, fileName);\n    try {\n      await this.unzipDriver(archivePath, targetPath);\n      await fs.chmod(targetPath, 0o755);\n      log.debug(`Permissions of the file '${targetPath}' have been changed to 755`);\n    } catch (e) {\n      if (isStrict) {\n        throw e;\n      }\n      log.error(e.message);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @typedef {Object} SyncOptions\n   * @property {Array<String>} versions - The list of chromedriver\n   * versions to sync. If empty (the default value) then all available\n   * chromedrivers are going to be downloaded and extracted\n   * @property {string|number} minBrowserVersion - The minumum supported\n   * Chrome version that downloaded chromedrivers should support. Can match\n   * multiple drivers.\n   * @property {?OSInfo} osInfo - System information used to filter out\n   * the list of the retrieved drivers. If not provided then the script\n   * will try to retrieve it.\n   */\n\n  /**\n   * Retrieves chromedrivers from the remote storage\n   * to the local file system\n   *\n   * @param {?SyncOptions} opts\n   * @throws {Error} if there was a problem while retrieving\n   * the drivers\n   * @returns {Array<String} The list of successfully synchronized driver keys\n   */\n  async syncDrivers (opts = {}) {\n    if (_.isEmpty(this.mapping)) {\n      await this.retrieveMapping(!!opts.minBrowserVersion);\n    }\n    if (_.isEmpty(this.mapping)) {\n      throw new Error('Cannot retrieve chromedrivers mapping from Google storage');\n    }\n\n    const driversToSync = this.selectMatchingDrivers(opts.osInfo ?? await getOsInfo(), opts);\n    if (_.isEmpty(driversToSync)) {\n      log.debug(`There are no drivers to sync. Exiting`);\n      return [];\n    }\n    log.debug(`Got ${util.pluralize('driver', driversToSync.length, true)} to sync: ` +\n      JSON.stringify(driversToSync, null, 2));\n\n    const synchronizedDrivers = [];\n    const promises = [];\n    const archivesRoot = await tempDir.openDir();\n    try {\n      for (const [idx, driverKey] of driversToSync.entries()) {\n        promises.push((async () => {\n          if (await this.retrieveDriver(idx, driverKey, archivesRoot, !_.isEmpty(opts))) {\n            synchronizedDrivers.push(driverKey);\n          }\n        })());\n\n        if (promises.length % MAX_PARALLEL_DOWNLOADS === 0) {\n          await B.all(promises);\n        }\n      }\n      await B.all(promises);\n    } finally {\n      await fs.rimraf(archivesRoot);\n    }\n    if (!_.isEmpty(synchronizedDrivers)) {\n      log.info(`Successfully synchronized ` +\n        `${util.pluralize('chromedriver', synchronizedDrivers.length, true)}`);\n    } else {\n      log.info(`No chromedrivers were synchronized`);\n    }\n    return synchronizedDrivers;\n  }\n}\n\n\nexport default ChromedriverStorageClient;\n"],"mappings":"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"}